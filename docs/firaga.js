(() => {
  var __defProp = Object.defineProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[Object.keys(cb)[0]])((mod = {exports: {}}).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, {get: all[name], enumerable: true});
  };

  // data/colors.csv
  var require_colors = __commonJS({
    "data/colors.csv"(exports, module) {
      module.exports = "R,G,B,Artkal Midi Soft,Artkal Mini Soft,Artkal Mini,Artkal Midi,Name\r\n255,255,255,R01,A01,C01,S01,White\r\n255,163,139,R02,A44,C44,S02,Burning Sand\r\n246,176,76,R03,A03,C03,S03,Tangerine\r\n255,103,31,R04,A17,C17,S04,Orange\r\n225,6,0,R05,A05,C05,S05,Tall Poppy\r\n236,134,208,R06,A49,C49,S06,Raspberry Pink\r\n155,155,155,R07,A33,C33,S07,Gray\r\n36,222,91,R08,,,S08,Emerald\r\n0,104,94,R09,,,S09,Dark Green\r\n65,182,230,R10,A19,C19,S10,Baby Blue\r\n79,159,179,,A99,C99,S100,Lagoon\r\n49,150,221,,A100,C100,S101,Electric Blue\r\n27,108,182,,A101,C101,S102,Pool Blue\r\n8,57,128,,A102,C102,S103,Caribbean Blue\r\n10,102,139,,A103,C103,S104,Deep Water\r\n8,91,110,,A104,C104,S105,Petrol Blue\r\n0,78,120,,A105,C105,S106,Wegdewood Blue\r\n0,85,116,,A106,C106,S107,Pond Blue\r\n204,190,128,,A107,C107,S108,Seashell Beige\r\n164,147,80,,A108,C108,S109,Beige\r\n0,51,153,R11,A21,C21,S11,Dark Blue\r\n158,136,60,,A109,C109,S110,Beach Beige\r\n118,108,43,,A110,C110,S111,Caffe Latt\xE9\r\n121,95,38,,A111,C111,S112,Oaktree Brown\r\n186,184,162,,A112,C112,S113,Khaki\r\n114,140,84,,A113,C113,S114,Light Greengray\r\n126,124,68,,A114,C114,S115,Mossy Green\r\n100,105,46,,A115,C115,S116,Earth Green\r\n78,88,44,,A116,C116,S117,Sage Green\r\n74,94,45,,A117,C117,S118,Pinetree Green\r\n113,196,182,,A118,C118,S119,Frosty Blue\r\n160,94,181,R12,A26,C26,S12,Pastel Lavender\r\n102,204,153,,A119,C119,S120,Polar Mint\r\n86,154,131,,A120,C120,S121,Celadon Green\r\n20,194,91,,A121,C121,S122,Eucalyptus\r\n24,168,24,,A122,C122,S123,Clover Field\r\n4,85,46,,A123,C123,S124,Pooltable Felt\r\n19,107,90,,A124,C124,S125,Snake Green\r\n5,70,65,,A125,C125,S126,Dark Eucalyptus\r\n217,182,214,,A126,C126,S127,Marsmallow Rose\r\n173,98,164,,A127,C127,S128,Light Grape\r\n230,140,163,,A128,C128,S129,Rosebud Pink\r\n0,0,0,R13,A02,C02,S13,Black\r\n222,84,121,,A129,C129,S130,Fuschia\r\n158,130,186,,A130,C130,S131,Candy Violet\r\n232,65,107,,A131,C131,S132,Flamingo\r\n183,56,143,,A132,C132,S133,Pink Plum\r\n88,31,126,,A133,C133,S134,Amethyst\r\n140,163,212,,A134,C134,S135,Moonlight Blue\r\n154,154,204,,A135,C135,S136,Summer Rain\r\n89,129,193,,A136,C136,S137,Azure Blue\r\n65,102,176,,A137,C137,S138,Cornflower Blue\r\n71,95,171,,A138,C138,S139,Forget Me Not\r\n250,224,83,R14,A42,C42,S14,Sandstorm\r\n55,69,147,,A139,C139,S140,Indigo\r\n61,86,165,,A140,C140,S141,Horizon Blue\r\n41,66,135,,A141,C141,S142,Cobalt\r\n37,38,138,,A142,C142,S143,Royal Blue\r\n26,47,111,,A143,C143,S144,Marine\r\n211,201,93,,A144,C144,S145,Pale Yellow Moss\r\n81,9,24,,A145,C145,S146,Bloodrose Red\r\n100,179,158,,A146,C146,S147,Spearmint\r\n99,67,56,,A147,C147,S148,Mocha\r\n237,211,158,,A148,C148,S149,Creme\r\n122,62,44,R15,A30,C30,S15,Redwood\r\n105,99,171,,A149,C149,S150,Iris Violet\r\n43,63,31,,A150,C150,S151,Forest Green\r\n151,145,197,,A151,C151,S152,Lilac\r\n184,189,224,,A152,C152,S153,Pale Lilac\r\n249,200,152,,A153,C153,S154,Sahara Sand\r\n195,144,105,,A154,C154,S155,Sunkissed Teint\r\n90,90,90,,A155,C155,S156,Steel Grey\r\n60,60,60,,A156,C156,S157,Iron Grey\r\n26,26,26,,A157,C157,S158,Pepper\r\n139,139,139,,A56,C56,S159,Oslo Gray\r\n92,71,56,R16,A32,C32,S16,Brown\r\n123,77,53,R17,A31,C31,S17,Light Brown\r\n204,153,102,R18,A23,C23,S18,Sand\r\n252,191,169,R19,A22,C22,S19,Bubble Gum\r\n36,158,107,R20,A14,C14,S20,Green\r\n135,216,57,R21,A13,C13,S21,Pastel Green\r\n51,0,114,R22,A27,C27,S22,Purple\r\n100,53,155,R23,,,S23,Royal Purple\r\n20,123,209,R24,A37,C37,S24,True Blue\r\n255,52,179,R25,A08,C08,S25,Hot Pink\r\n219,33,82,R26,A09,C09,S26,Magenta\r\n255,209,0,R27,A11,C11,S27,Yellow\r\n234,184,228,R28,,,S28,Lily Pink\r\n246,235,97,R29,A41,C41,S29,Pastel Yellow\r\n153,214,234,R30,A39,C39,S30,Shadow Green\r\n158,229,176,R31,A60,C60,S31,Sea Mist\r\n255,231,128,R32,A24,C24,S32,Beeswax\r\n197,180,227,R33,A50,C50,S33,Maverick\r\n186,12,47,R34,A06,C06,S34,Red\r\n247,206,215,R35,,,S35,Mona Lisa\r\n201,128,158,R36,A36,C36,S36,Old Pink\r\n113,216,191,R37,,,S37,Blue-Green\r\n171,37,86,R38,,,S38,Burgundy\r\n237,139,0,R39,A04,C04,S39,Yellow Orange\r\n241,167,220,R40,A07,C07,S40,Carnation Pink\r\n154,85,22,R41,,,S41,Metallic Gold\r\n125,124,121,R42,A35,C35,S42,Metallic Silver\r\n118,119,119,R43,A34,C34,S43,Dark Gray\r\n170,220,235,R44,A18,C18,S44,Sky Blue\r\n0,178,169,R45,A54,C54,S45,Medium Turquoise\r\n115,211,60,R46,A53,C53,S46,Bright Green\r\n180,126,0,R47,A28,C28,S47,Marigold\r\n255,199,44,R48,A48,C48,S48,Corn\r\n114,25,95,R49,,,S49,Mulberry Wood\r\n250,170,114,R50,,,S50,Mandy's Pink\r\n252,251,205,R51,A51,C51,S51,Spring Sun\r\n242,240,161,R52,A10,C10,S52,Picasso\r\n105,179,231,R53,A38,C38,S53,Turquoise\r\n0,144,218,R54,A20,C20,S54,Light Blue\r\n173,220,145,R57,A12,C12,S55,Pistachio\r\n255,106,19,R59,A16,C16,S56,Bright Carrot\r\n164,73,61,R63,A29,C29,S57,Buccaneer\r\n165,0,52,R64,A43,C43,S58,Paprika\r\n74,31,135,,A52,C52,S59,Butterfly Bush\r\n167,123,202,R66,A25,C25,S60,Lavender\r\n206,220,0,R68,A40,C40,S61,Key Lime Pie\r\n0,124,88,R69,A15,C15,S62,Green Tea\r\n88,87,53,R70,,,S63,Metallic Copper\r\n5,8,73,R55,A58,C58,S64,Black Rock\r\n243,234,93,R58,A46,C46,S65,Canary\r\n244,99,58,R60,,,S66,Blaze Orange\r\n243,207,179,R61,A47,C47,S67,Vanilla\r\n225,192,120,R71,,,S68,Tan\r\n40,40,40,R72,A69,C69,S69,Mine Shaft\r\n155,188,17,R89,A84,C84,S70,Dark Algae\r\n0,133,34,R73,A86,C86,S71,Jade Green\r\n89,213,216,R74,A79,C79,S72,Light Sea Blue\r\n72,169,197,R91,A81,C81,S73,Steel Blue\r\n0,174,214,R75,A82,C82,S74,Azure\r\n0,133,173,R92,A83,C83,S75,Dark Steel Blue\r\n0,174,199,R76,A80,C80,S76,Sea Blue\r\n239,239,239,R77,A87,C87,S77,Ghost While\r\n209,209,209,R78,A88,C88,S78,Ash Grey\r\n187,188,188,R79,A89,C89,S79,Light Gray\r\n153,155,48,R90,A85,C85,S80,Dark Olive\r\n205,178,119,R81,A74,C74,S81,Deer\r\n181,129,80,R82,A75,C75,S82,Clay\r\n184,97,37,R83,A73,C73,S83,Sienna\r\n170,87,97,R84,A77,C77,S84,Deep Chestnut\r\n92,19,27,R85,A78,C78,S85,Red Wine\r\n234,170,0,R86,A71,C71,S86,Goldenrod\r\n255,109,106,R87,A76,C76,S87,Coral Red\r\n218,24,132,,,,S88,Dark Pink\r\n77,77,77,R88,A90,C90,S89,Charcoal Gray\r\n255,197,110,R80,A72,C72,S90,Pastel Orange\r\n24,48,40,R93,A70,C70,S91,Brunswick Green\r\n222,185,71,,A91,C91,S92,Dandelion\r\n218,182,152,,A92,C92,S93,Pale Skin\r\n244,169,153,,A93,C93,S94,Warm Blush\r\n238,125,103,,A94,C94,S95,Salmon\r\n240,134,97,,A95,C95,S96,Apricot\r\n212,114,42,,A96,C96,S97,Papaya\r\n100,172,223,,A97,C97,S98,Himalaya Blue\r\n100,194,220,,A98,C98,S99,Waterfall\r\n93,219,93,R56,A45,C45,,Spring Green\r\n108,194,74,,A55,C55,,Confier\r\n188,4,35,R65,A57,C57,,Fresh Red\r\n83,26,35,R62,A59,C59,,Scarlett\r\n241,235,156,,A61,C61,,Feta\r\n252,63,63,,A62,C62,,Carnation\r\n234,190,219,,A63,C63,,Pink Pearl\r\n165,0,80,,A64,C64,,Rose\r\n239,129,46,,A65,C65,,Mango Tango\r\n252,108,133,,A66,C66,,Wild Watermelon\r\n177,78,181,,A67,C67,,Orchid\r\n105,194,238,,A68,C68,,Toothpaste Blue\r\n255,197,110,R67,,,,Yolk Yellow";
    }
  });

  // node_modules/preact/dist/preact.module.js
  var preact_module_exports = {};
  __export(preact_module_exports, {
    Component: () => p,
    Fragment: () => y,
    cloneElement: () => S,
    createContext: () => q,
    createElement: () => a,
    createRef: () => h,
    h: () => a,
    hydrate: () => O,
    isValidElement: () => l,
    options: () => n,
    render: () => N,
    toChildArray: () => w
  });
  function c(n2, l2) {
    for (var u2 in l2)
      n2[u2] = l2[u2];
    return n2;
  }
  function s(n2) {
    var l2 = n2.parentNode;
    l2 && l2.removeChild(n2);
  }
  function a(n2, l2, u2) {
    var i2, t2, o2, r2 = arguments, f2 = {};
    for (o2 in l2)
      o2 == "key" ? i2 = l2[o2] : o2 == "ref" ? t2 = l2[o2] : f2[o2] = l2[o2];
    if (arguments.length > 3)
      for (u2 = [u2], o2 = 3; o2 < arguments.length; o2++)
        u2.push(r2[o2]);
    if (u2 != null && (f2.children = u2), typeof n2 == "function" && n2.defaultProps != null)
      for (o2 in n2.defaultProps)
        f2[o2] === void 0 && (f2[o2] = n2.defaultProps[o2]);
    return v(n2, f2, i2, t2, null);
  }
  function v(l2, u2, i2, t2, o2) {
    var r2 = {type: l2, props: u2, key: i2, ref: t2, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: o2 == null ? ++n.__v : o2};
    return n.vnode != null && n.vnode(r2), r2;
  }
  function h() {
    return {current: null};
  }
  function y(n2) {
    return n2.children;
  }
  function p(n2, l2) {
    this.props = n2, this.context = l2;
  }
  function d(n2, l2) {
    if (l2 == null)
      return n2.__ ? d(n2.__, n2.__.__k.indexOf(n2) + 1) : null;
    for (var u2; l2 < n2.__k.length; l2++)
      if ((u2 = n2.__k[l2]) != null && u2.__e != null)
        return u2.__e;
    return typeof n2.type == "function" ? d(n2) : null;
  }
  function _(n2) {
    var l2, u2;
    if ((n2 = n2.__) != null && n2.__c != null) {
      for (n2.__e = n2.__c.base = null, l2 = 0; l2 < n2.__k.length; l2++)
        if ((u2 = n2.__k[l2]) != null && u2.__e != null) {
          n2.__e = n2.__c.base = u2.__e;
          break;
        }
      return _(n2);
    }
  }
  function k(l2) {
    (!l2.__d && (l2.__d = true) && u.push(l2) && !b.__r++ || t !== n.debounceRendering) && ((t = n.debounceRendering) || i)(b);
  }
  function b() {
    for (var n2; b.__r = u.length; )
      n2 = u.sort(function(n3, l2) {
        return n3.__v.__b - l2.__v.__b;
      }), u = [], n2.some(function(n3) {
        var l2, u2, i2, t2, o2, r2;
        n3.__d && (o2 = (t2 = (l2 = n3).__v).__e, (r2 = l2.__P) && (u2 = [], (i2 = c({}, t2)).__v = t2.__v + 1, I(r2, t2, i2, l2.__n, r2.ownerSVGElement !== void 0, t2.__h != null ? [o2] : null, u2, o2 == null ? d(t2) : o2, t2.__h), T(u2, t2), t2.__e != o2 && _(t2)));
      });
  }
  function m(n2, l2, u2, i2, t2, o2, e2, c2, s2, a2) {
    var h2, p2, _2, k2, b2, m2, w2, A2 = i2 && i2.__k || f, P2 = A2.length;
    for (u2.__k = [], h2 = 0; h2 < l2.length; h2++)
      if ((k2 = u2.__k[h2] = (k2 = l2[h2]) == null || typeof k2 == "boolean" ? null : typeof k2 == "string" || typeof k2 == "number" || typeof k2 == "bigint" ? v(null, k2, null, null, k2) : Array.isArray(k2) ? v(y, {children: k2}, null, null, null) : k2.__b > 0 ? v(k2.type, k2.props, k2.key, null, k2.__v) : k2) != null) {
        if (k2.__ = u2, k2.__b = u2.__b + 1, (_2 = A2[h2]) === null || _2 && k2.key == _2.key && k2.type === _2.type)
          A2[h2] = void 0;
        else
          for (p2 = 0; p2 < P2; p2++) {
            if ((_2 = A2[p2]) && k2.key == _2.key && k2.type === _2.type) {
              A2[p2] = void 0;
              break;
            }
            _2 = null;
          }
        I(n2, k2, _2 = _2 || r, t2, o2, e2, c2, s2, a2), b2 = k2.__e, (p2 = k2.ref) && _2.ref != p2 && (w2 || (w2 = []), _2.ref && w2.push(_2.ref, null, k2), w2.push(p2, k2.__c || b2, k2)), b2 != null ? (m2 == null && (m2 = b2), typeof k2.type == "function" && k2.__k != null && k2.__k === _2.__k ? k2.__d = s2 = g(k2, s2, n2) : s2 = x(n2, k2, _2, A2, b2, s2), a2 || u2.type !== "option" ? typeof u2.type == "function" && (u2.__d = s2) : n2.value = "") : s2 && _2.__e == s2 && s2.parentNode != n2 && (s2 = d(_2));
      }
    for (u2.__e = m2, h2 = P2; h2--; )
      A2[h2] != null && (typeof u2.type == "function" && A2[h2].__e != null && A2[h2].__e == u2.__d && (u2.__d = d(i2, h2 + 1)), L(A2[h2], A2[h2]));
    if (w2)
      for (h2 = 0; h2 < w2.length; h2++)
        z(w2[h2], w2[++h2], w2[++h2]);
  }
  function g(n2, l2, u2) {
    var i2, t2;
    for (i2 = 0; i2 < n2.__k.length; i2++)
      (t2 = n2.__k[i2]) && (t2.__ = n2, l2 = typeof t2.type == "function" ? g(t2, l2, u2) : x(u2, t2, t2, n2.__k, t2.__e, l2));
    return l2;
  }
  function w(n2, l2) {
    return l2 = l2 || [], n2 == null || typeof n2 == "boolean" || (Array.isArray(n2) ? n2.some(function(n3) {
      w(n3, l2);
    }) : l2.push(n2)), l2;
  }
  function x(n2, l2, u2, i2, t2, o2) {
    var r2, f2, e2;
    if (l2.__d !== void 0)
      r2 = l2.__d, l2.__d = void 0;
    else if (u2 == null || t2 != o2 || t2.parentNode == null)
      n:
        if (o2 == null || o2.parentNode !== n2)
          n2.appendChild(t2), r2 = null;
        else {
          for (f2 = o2, e2 = 0; (f2 = f2.nextSibling) && e2 < i2.length; e2 += 2)
            if (f2 == t2)
              break n;
          n2.insertBefore(t2, o2), r2 = o2;
        }
    return r2 !== void 0 ? r2 : t2.nextSibling;
  }
  function A(n2, l2, u2, i2, t2) {
    var o2;
    for (o2 in u2)
      o2 === "children" || o2 === "key" || o2 in l2 || C(n2, o2, null, u2[o2], i2);
    for (o2 in l2)
      t2 && typeof l2[o2] != "function" || o2 === "children" || o2 === "key" || o2 === "value" || o2 === "checked" || u2[o2] === l2[o2] || C(n2, o2, l2[o2], u2[o2], i2);
  }
  function P(n2, l2, u2) {
    l2[0] === "-" ? n2.setProperty(l2, u2) : n2[l2] = u2 == null ? "" : typeof u2 != "number" || e.test(l2) ? u2 : u2 + "px";
  }
  function C(n2, l2, u2, i2, t2) {
    var o2;
    n:
      if (l2 === "style")
        if (typeof u2 == "string")
          n2.style.cssText = u2;
        else {
          if (typeof i2 == "string" && (n2.style.cssText = i2 = ""), i2)
            for (l2 in i2)
              u2 && l2 in u2 || P(n2.style, l2, "");
          if (u2)
            for (l2 in u2)
              i2 && u2[l2] === i2[l2] || P(n2.style, l2, u2[l2]);
        }
      else if (l2[0] === "o" && l2[1] === "n")
        o2 = l2 !== (l2 = l2.replace(/Capture$/, "")), l2 = l2.toLowerCase() in n2 ? l2.toLowerCase().slice(2) : l2.slice(2), n2.l || (n2.l = {}), n2.l[l2 + o2] = u2, u2 ? i2 || n2.addEventListener(l2, o2 ? H : $, o2) : n2.removeEventListener(l2, o2 ? H : $, o2);
      else if (l2 !== "dangerouslySetInnerHTML") {
        if (t2)
          l2 = l2.replace(/xlink[H:h]/, "h").replace(/sName$/, "s");
        else if (l2 !== "href" && l2 !== "list" && l2 !== "form" && l2 !== "tabIndex" && l2 !== "download" && l2 in n2)
          try {
            n2[l2] = u2 == null ? "" : u2;
            break n;
          } catch (n3) {
          }
        typeof u2 == "function" || (u2 != null && (u2 !== false || l2[0] === "a" && l2[1] === "r") ? n2.setAttribute(l2, u2) : n2.removeAttribute(l2));
      }
  }
  function $(l2) {
    this.l[l2.type + false](n.event ? n.event(l2) : l2);
  }
  function H(l2) {
    this.l[l2.type + true](n.event ? n.event(l2) : l2);
  }
  function I(l2, u2, i2, t2, o2, r2, f2, e2, s2) {
    var a2, v2, h2, d2, _2, k2, b2, g2, w2, x2, A2, P2 = u2.type;
    if (u2.constructor !== void 0)
      return null;
    i2.__h != null && (s2 = i2.__h, e2 = u2.__e = i2.__e, u2.__h = null, r2 = [e2]), (a2 = n.__b) && a2(u2);
    try {
      n:
        if (typeof P2 == "function") {
          if (g2 = u2.props, w2 = (a2 = P2.contextType) && t2[a2.__c], x2 = a2 ? w2 ? w2.props.value : a2.__ : t2, i2.__c ? b2 = (v2 = u2.__c = i2.__c).__ = v2.__E : ("prototype" in P2 && P2.prototype.render ? u2.__c = v2 = new P2(g2, x2) : (u2.__c = v2 = new p(g2, x2), v2.constructor = P2, v2.render = M), w2 && w2.sub(v2), v2.props = g2, v2.state || (v2.state = {}), v2.context = x2, v2.__n = t2, h2 = v2.__d = true, v2.__h = []), v2.__s == null && (v2.__s = v2.state), P2.getDerivedStateFromProps != null && (v2.__s == v2.state && (v2.__s = c({}, v2.__s)), c(v2.__s, P2.getDerivedStateFromProps(g2, v2.__s))), d2 = v2.props, _2 = v2.state, h2)
            P2.getDerivedStateFromProps == null && v2.componentWillMount != null && v2.componentWillMount(), v2.componentDidMount != null && v2.__h.push(v2.componentDidMount);
          else {
            if (P2.getDerivedStateFromProps == null && g2 !== d2 && v2.componentWillReceiveProps != null && v2.componentWillReceiveProps(g2, x2), !v2.__e && v2.shouldComponentUpdate != null && v2.shouldComponentUpdate(g2, v2.__s, x2) === false || u2.__v === i2.__v) {
              v2.props = g2, v2.state = v2.__s, u2.__v !== i2.__v && (v2.__d = false), v2.__v = u2, u2.__e = i2.__e, u2.__k = i2.__k, u2.__k.forEach(function(n2) {
                n2 && (n2.__ = u2);
              }), v2.__h.length && f2.push(v2);
              break n;
            }
            v2.componentWillUpdate != null && v2.componentWillUpdate(g2, v2.__s, x2), v2.componentDidUpdate != null && v2.__h.push(function() {
              v2.componentDidUpdate(d2, _2, k2);
            });
          }
          v2.context = x2, v2.props = g2, v2.state = v2.__s, (a2 = n.__r) && a2(u2), v2.__d = false, v2.__v = u2, v2.__P = l2, a2 = v2.render(v2.props, v2.state, v2.context), v2.state = v2.__s, v2.getChildContext != null && (t2 = c(c({}, t2), v2.getChildContext())), h2 || v2.getSnapshotBeforeUpdate == null || (k2 = v2.getSnapshotBeforeUpdate(d2, _2)), A2 = a2 != null && a2.type === y && a2.key == null ? a2.props.children : a2, m(l2, Array.isArray(A2) ? A2 : [A2], u2, i2, t2, o2, r2, f2, e2, s2), v2.base = u2.__e, u2.__h = null, v2.__h.length && f2.push(v2), b2 && (v2.__E = v2.__ = null), v2.__e = false;
        } else
          r2 == null && u2.__v === i2.__v ? (u2.__k = i2.__k, u2.__e = i2.__e) : u2.__e = j(i2.__e, u2, i2, t2, o2, r2, f2, s2);
      (a2 = n.diffed) && a2(u2);
    } catch (l3) {
      u2.__v = null, (s2 || r2 != null) && (u2.__e = e2, u2.__h = !!s2, r2[r2.indexOf(e2)] = null), n.__e(l3, u2, i2);
    }
  }
  function T(l2, u2) {
    n.__c && n.__c(u2, l2), l2.some(function(u3) {
      try {
        l2 = u3.__h, u3.__h = [], l2.some(function(n2) {
          n2.call(u3);
        });
      } catch (l3) {
        n.__e(l3, u3.__v);
      }
    });
  }
  function j(n2, l2, u2, i2, t2, o2, e2, c2) {
    var a2, v2, h2, y2, p2 = u2.props, d2 = l2.props, _2 = l2.type, k2 = 0;
    if (_2 === "svg" && (t2 = true), o2 != null) {
      for (; k2 < o2.length; k2++)
        if ((a2 = o2[k2]) && (a2 === n2 || (_2 ? a2.localName == _2 : a2.nodeType == 3))) {
          n2 = a2, o2[k2] = null;
          break;
        }
    }
    if (n2 == null) {
      if (_2 === null)
        return document.createTextNode(d2);
      n2 = t2 ? document.createElementNS("http://www.w3.org/2000/svg", _2) : document.createElement(_2, d2.is && d2), o2 = null, c2 = false;
    }
    if (_2 === null)
      p2 === d2 || c2 && n2.data === d2 || (n2.data = d2);
    else {
      if (o2 = o2 && f.slice.call(n2.childNodes), v2 = (p2 = u2.props || r).dangerouslySetInnerHTML, h2 = d2.dangerouslySetInnerHTML, !c2) {
        if (o2 != null)
          for (p2 = {}, y2 = 0; y2 < n2.attributes.length; y2++)
            p2[n2.attributes[y2].name] = n2.attributes[y2].value;
        (h2 || v2) && (h2 && (v2 && h2.__html == v2.__html || h2.__html === n2.innerHTML) || (n2.innerHTML = h2 && h2.__html || ""));
      }
      if (A(n2, d2, p2, t2, c2), h2)
        l2.__k = [];
      else if (k2 = l2.props.children, m(n2, Array.isArray(k2) ? k2 : [k2], l2, u2, i2, t2 && _2 !== "foreignObject", o2, e2, n2.firstChild, c2), o2 != null)
        for (k2 = o2.length; k2--; )
          o2[k2] != null && s(o2[k2]);
      c2 || ("value" in d2 && (k2 = d2.value) !== void 0 && (k2 !== n2.value || _2 === "progress" && !k2) && C(n2, "value", k2, p2.value, false), "checked" in d2 && (k2 = d2.checked) !== void 0 && k2 !== n2.checked && C(n2, "checked", k2, p2.checked, false));
    }
    return n2;
  }
  function z(l2, u2, i2) {
    try {
      typeof l2 == "function" ? l2(u2) : l2.current = u2;
    } catch (l3) {
      n.__e(l3, i2);
    }
  }
  function L(l2, u2, i2) {
    var t2, o2, r2;
    if (n.unmount && n.unmount(l2), (t2 = l2.ref) && (t2.current && t2.current !== l2.__e || z(t2, null, u2)), i2 || typeof l2.type == "function" || (i2 = (o2 = l2.__e) != null), l2.__e = l2.__d = void 0, (t2 = l2.__c) != null) {
      if (t2.componentWillUnmount)
        try {
          t2.componentWillUnmount();
        } catch (l3) {
          n.__e(l3, u2);
        }
      t2.base = t2.__P = null;
    }
    if (t2 = l2.__k)
      for (r2 = 0; r2 < t2.length; r2++)
        t2[r2] && L(t2[r2], u2, i2);
    o2 != null && s(o2);
  }
  function M(n2, l2, u2) {
    return this.constructor(n2, u2);
  }
  function N(l2, u2, i2) {
    var t2, o2, e2;
    n.__ && n.__(l2, u2), o2 = (t2 = typeof i2 == "function") ? null : i2 && i2.__k || u2.__k, e2 = [], I(u2, l2 = (!t2 && i2 || u2).__k = a(y, null, [l2]), o2 || r, r, u2.ownerSVGElement !== void 0, !t2 && i2 ? [i2] : o2 ? null : u2.firstChild ? f.slice.call(u2.childNodes) : null, e2, !t2 && i2 ? i2 : o2 ? o2.__e : u2.firstChild, t2), T(e2, l2);
  }
  function O(n2, l2) {
    N(n2, l2, O);
  }
  function S(n2, l2, u2) {
    var i2, t2, o2, r2 = arguments, f2 = c({}, n2.props);
    for (o2 in l2)
      o2 == "key" ? i2 = l2[o2] : o2 == "ref" ? t2 = l2[o2] : f2[o2] = l2[o2];
    if (arguments.length > 3)
      for (u2 = [u2], o2 = 3; o2 < arguments.length; o2++)
        u2.push(r2[o2]);
    return u2 != null && (f2.children = u2), v(n2.type, f2, i2 || n2.key, t2 || n2.ref, null);
  }
  function q(n2, l2) {
    var u2 = {__c: l2 = "__cC" + o++, __: n2, Consumer: function(n3, l3) {
      return n3.children(l3);
    }, Provider: function(n3) {
      var u3, i2;
      return this.getChildContext || (u3 = [], (i2 = {})[l2] = this, this.getChildContext = function() {
        return i2;
      }, this.shouldComponentUpdate = function(n4) {
        this.props.value !== n4.value && u3.some(k);
      }, this.sub = function(n4) {
        u3.push(n4);
        var l3 = n4.componentWillUnmount;
        n4.componentWillUnmount = function() {
          u3.splice(u3.indexOf(n4), 1), l3 && l3.call(n4);
        };
      }), n3.children;
    }};
    return u2.Provider.__ = u2.Consumer.contextType = u2;
  }
  var n, l, u, i, t, o, r, f, e;
  var init_preact_module = __esm({
    "node_modules/preact/dist/preact.module.js"() {
      r = {};
      f = [];
      e = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
      n = {__e: function(n2, l2) {
        for (var u2, i2, t2; l2 = l2.__; )
          if ((u2 = l2.__c) && !u2.__)
            try {
              if ((i2 = u2.constructor) && i2.getDerivedStateFromError != null && (u2.setState(i2.getDerivedStateFromError(n2)), t2 = u2.__d), u2.componentDidCatch != null && (u2.componentDidCatch(n2), t2 = u2.__d), t2)
                return u2.__E = u2;
            } catch (l3) {
              n2 = l3;
            }
        throw n2;
      }, __v: 0}, l = function(n2) {
        return n2 != null && n2.constructor === void 0;
      }, p.prototype.setState = function(n2, l2) {
        var u2;
        u2 = this.__s != null && this.__s !== this.state ? this.__s : this.__s = c({}, this.state), typeof n2 == "function" && (n2 = n2(c({}, u2), this.props)), n2 && c(u2, n2), n2 != null && this.__v && (l2 && this.__h.push(l2), k(this));
      }, p.prototype.forceUpdate = function(n2) {
        this.__v && (this.__e = true, n2 && this.__h.push(n2), k(this));
      }, p.prototype.render = y, u = [], i = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, b.__r = 0, o = 0;
    }
  });

  // node_modules/color-diff/lib/diff.js
  var require_diff = __commonJS({
    "node_modules/color-diff/lib/diff.js"(exports) {
      exports.ciede2000 = ciede2000;
      var sqrt = Math.sqrt;
      var pow = Math.pow;
      var cos = Math.cos;
      var atan2 = Math.atan2;
      var sin = Math.sin;
      var abs = Math.abs;
      var exp = Math.exp;
      var PI = Math.PI;
      function ciede2000(c1, c2) {
        var L1 = c1.L;
        var a1 = c1.a;
        var b1 = c1.b;
        var L2 = c2.L;
        var a2 = c2.a;
        var b2 = c2.b;
        var kL = 1;
        var kC = 1;
        var kH = 1;
        var C1 = sqrt(pow(a1, 2) + pow(b1, 2));
        var C2 = sqrt(pow(a2, 2) + pow(b2, 2));
        var a_C1_C2 = (C1 + C2) / 2;
        var G = 0.5 * (1 - sqrt(pow(a_C1_C2, 7) / (pow(a_C1_C2, 7) + pow(25, 7))));
        var a1p = (1 + G) * a1;
        var a2p = (1 + G) * a2;
        var C1p = sqrt(pow(a1p, 2) + pow(b1, 2));
        var C2p = sqrt(pow(a2p, 2) + pow(b2, 2));
        var h1p = hp_f(b1, a1p);
        var h2p = hp_f(b2, a2p);
        var dLp = L2 - L1;
        var dCp = C2p - C1p;
        var dhp = dhp_f(C1, C2, h1p, h2p);
        var dHp = 2 * sqrt(C1p * C2p) * sin(radians(dhp) / 2);
        var a_L = (L1 + L2) / 2;
        var a_Cp = (C1p + C2p) / 2;
        var a_hp = a_hp_f(C1, C2, h1p, h2p);
        var T2 = 1 - 0.17 * cos(radians(a_hp - 30)) + 0.24 * cos(radians(2 * a_hp)) + 0.32 * cos(radians(3 * a_hp + 6)) - 0.2 * cos(radians(4 * a_hp - 63));
        var d_ro = 30 * exp(-pow((a_hp - 275) / 25, 2));
        var RC = sqrt(pow(a_Cp, 7) / (pow(a_Cp, 7) + pow(25, 7)));
        var SL = 1 + 0.015 * pow(a_L - 50, 2) / sqrt(20 + pow(a_L - 50, 2));
        var SC = 1 + 0.045 * a_Cp;
        var SH = 1 + 0.015 * a_Cp * T2;
        var RT = -2 * RC * sin(radians(2 * d_ro));
        var dE = sqrt(pow(dLp / (SL * kL), 2) + pow(dCp / (SC * kC), 2) + pow(dHp / (SH * kH), 2) + RT * (dCp / (SC * kC)) * (dHp / (SH * kH)));
        return dE;
      }
      function degrees(n2) {
        return n2 * (180 / PI);
      }
      function radians(n2) {
        return n2 * (PI / 180);
      }
      function hp_f(x2, y2) {
        if (x2 === 0 && y2 === 0)
          return 0;
        else {
          var tmphp = degrees(atan2(x2, y2));
          if (tmphp >= 0)
            return tmphp;
          else
            return tmphp + 360;
        }
      }
      function dhp_f(C1, C2, h1p, h2p) {
        if (C1 * C2 === 0)
          return 0;
        else if (abs(h2p - h1p) <= 180)
          return h2p - h1p;
        else if (h2p - h1p > 180)
          return h2p - h1p - 360;
        else if (h2p - h1p < -180)
          return h2p - h1p + 360;
        else
          throw new Error();
      }
      function a_hp_f(C1, C2, h1p, h2p) {
        if (C1 * C2 === 0)
          return h1p + h2p;
        else if (abs(h1p - h2p) <= 180)
          return (h1p + h2p) / 2;
        else if (abs(h1p - h2p) > 180 && h1p + h2p < 360)
          return (h1p + h2p + 360) / 2;
        else if (abs(h1p - h2p) > 180 && h1p + h2p >= 360)
          return (h1p + h2p - 360) / 2;
        else
          throw new Error();
      }
    }
  });

  // node_modules/color-diff/lib/convert.js
  var require_convert = __commonJS({
    "node_modules/color-diff/lib/convert.js"(exports) {
      exports.rgb_to_lab = rgb_to_lab;
      exports.rgba_to_lab = rgba_to_lab;
      exports.normalize_rgb = normalize_rgb;
      var pow = Math.pow;
      function rgba_to_lab(c2, bc) {
        c2 = normalize_rgb(c2);
        var bc = typeof bc !== "undefined" ? normalize_rgb(bc) : {R: 255, G: 255, B: 255};
        var new_c = {
          R: bc.R + (c2.R - bc.R) * c2.A,
          G: bc.G + (c2.G - bc.G) * c2.A,
          B: bc.B + (c2.B - bc.B) * c2.A
        };
        return rgb_to_lab(new_c);
      }
      function rgb_to_lab(c2) {
        return xyz_to_lab(rgb_to_xyz(c2));
      }
      function rgb_to_xyz(c2) {
        c2 = normalize_rgb(c2);
        var R = c2.R / 255;
        var G = c2.G / 255;
        var B = c2.B / 255;
        if (R > 0.04045)
          R = pow((R + 0.055) / 1.055, 2.4);
        else
          R = R / 12.92;
        if (G > 0.04045)
          G = pow((G + 0.055) / 1.055, 2.4);
        else
          G = G / 12.92;
        if (B > 0.04045)
          B = pow((B + 0.055) / 1.055, 2.4);
        else
          B = B / 12.92;
        R *= 100;
        G *= 100;
        B *= 100;
        var X = R * 0.4124 + G * 0.3576 + B * 0.1805;
        var Y = R * 0.2126 + G * 0.7152 + B * 0.0722;
        var Z = R * 0.0193 + G * 0.1192 + B * 0.9505;
        return {"X": X, "Y": Y, "Z": Z};
      }
      function xyz_to_lab(c2) {
        var ref_Y = 100;
        var ref_Z = 108.883;
        var ref_X = 95.047;
        var Y = c2.Y / ref_Y;
        var Z = c2.Z / ref_Z;
        var X = c2.X / ref_X;
        if (X > 8856e-6)
          X = pow(X, 1 / 3);
        else
          X = 7.787 * X + 16 / 116;
        if (Y > 8856e-6)
          Y = pow(Y, 1 / 3);
        else
          Y = 7.787 * Y + 16 / 116;
        if (Z > 8856e-6)
          Z = pow(Z, 1 / 3);
        else
          Z = 7.787 * Z + 16 / 116;
        var L2 = 116 * Y - 16;
        var a2 = 500 * (X - Y);
        var b2 = 200 * (Y - Z);
        return {"L": L2, "a": a2, "b": b2};
      }
      function normalize_rgb(c2) {
        var new_c = {
          R: c2.R || c2.r || 0,
          G: c2.G || c2.g || 0,
          B: c2.B || c2.b || 0
        };
        if (typeof c2.a !== "undefined" || typeof c2.A !== "undefined") {
          new_c.A = c2.A || c2.a || 0;
        }
        return new_c;
      }
    }
  });

  // node_modules/color-diff/lib/palette.js
  var require_palette = __commonJS({
    "node_modules/color-diff/lib/palette.js"(exports) {
      exports.map_palette = map_palette;
      exports.map_palette_lab = map_palette_lab;
      exports.match_palette_lab = match_palette_lab;
      exports.palette_map_key = palette_map_key;
      exports.lab_palette_map_key = lab_palette_map_key;
      var ciede2000 = require_diff().ciede2000;
      var color_convert = require_convert();
      function palette_map_key(c2) {
        c2 = color_convert.normalize_rgb(c2);
        var s2 = "R" + c2.R + "B" + c2.B + "G" + c2.G;
        if ("A" in c2) {
          s2 = s2 + "A" + c2.A;
        }
        return s2;
      }
      function lab_palette_map_key(c2) {
        return "L" + c2.L + "a" + c2.a + "b" + c2.b;
      }
      function map_palette(a2, b2, type, bc) {
        var c2 = {};
        bc = typeof bc !== "undefined" ? bc : {R: 255, G: 255, B: 255};
        type = type || "closest";
        for (var idx1 = 0; idx1 < a2.length; idx1 += 1) {
          var color1 = a2[idx1];
          var best_color = void 0;
          var best_color_diff = void 0;
          for (var idx2 = 0; idx2 < b2.length; idx2 += 1) {
            var color2 = b2[idx2];
            var current_color_diff = diff3(color1, color2, bc);
            if (best_color == void 0 || type === "closest" && current_color_diff < best_color_diff) {
              best_color = color2;
              best_color_diff = current_color_diff;
              continue;
            }
            if (type === "furthest" && current_color_diff > best_color_diff) {
              best_color = color2;
              best_color_diff = current_color_diff;
              continue;
            }
          }
          c2[palette_map_key(color1)] = best_color;
        }
        return c2;
      }
      function match_palette_lab(target_color, palette, find_furthest) {
        var color2, current_color_diff;
        var best_color = palette[0];
        var best_color_diff = ciede2000(target_color, best_color);
        for (var idx2 = 1, l2 = palette.length; idx2 < l2; idx2 += 1) {
          color2 = palette[idx2];
          current_color_diff = ciede2000(target_color, color2);
          if (!find_furthest && current_color_diff < best_color_diff || find_furthest && current_color_diff > best_color_diff) {
            best_color = color2;
            best_color_diff = current_color_diff;
          }
        }
        return best_color;
      }
      function map_palette_lab(a2, b2, type) {
        var c2 = {};
        var find_furthest = type === "furthest";
        for (var idx1 = 0; idx1 < a2.length; idx1 += 1) {
          var color1 = a2[idx1];
          c2[lab_palette_map_key(color1)] = match_palette_lab(color1, b2, find_furthest);
        }
        return c2;
      }
      function diff3(c1, c2, bc) {
        var conv_c1 = color_convert.rgb_to_lab;
        var conv_c2 = color_convert.rgb_to_lab;
        var rgba_conv = function(x2) {
          return color_convert.rgba_to_lab(x2, bc);
        };
        if ("A" in c1) {
          conv_c1 = rgba_conv;
        }
        if ("A" in c2) {
          conv_c2 = rgba_conv;
        }
        c1 = conv_c1(c1);
        c2 = conv_c2(c2);
        return ciede2000(c1, c2);
      }
    }
  });

  // node_modules/color-diff/lib/index.js
  var require_lib = __commonJS({
    "node_modules/color-diff/lib/index.js"(exports, module) {
      "use strict";
      var diff3 = require_diff();
      var convert = require_convert();
      var palette = require_palette();
      var color = module.exports = {};
      color.diff = diff3.ciede2000;
      color.rgb_to_lab = convert.rgb_to_lab;
      color.rgba_to_lab = convert.rgba_to_lab;
      color.map_palette = palette.map_palette;
      color.palette_map_key = palette.palette_map_key;
      color.map_palette_lab = palette.map_palette_lab;
      color.lab_palette_map_key = palette.lab_palette_map_key;
      color.match_palette_lab = palette.match_palette_lab;
      color.closest = function(target, relative, bc) {
        var key = color.palette_map_key(target);
        bc = typeof bc !== "undefined" ? bc : {R: 255, G: 255, B: 255};
        var result = color.map_palette([target], relative, "closest", bc);
        return result[key];
      };
      color.furthest = function(target, relative, bc) {
        var key = color.palette_map_key(target);
        bc = typeof bc !== "undefined" ? bc : {R: 255, G: 255, B: 255};
        var result = color.map_palette([target], relative, "furthest", bc);
        return result[key];
      };
      color.closest_lab = function(target, relative) {
        return color.match_palette_lab(target, relative, false);
      };
      color.furthest_lab = function(target, relative) {
        return color.match_palette_lab(target, relative, true);
      };
    }
  });

  // node_modules/color-name/index.js
  var require_color_name = __commonJS({
    "node_modules/color-name/index.js"(exports, module) {
      "use strict";
      module.exports = {
        "aliceblue": [240, 248, 255],
        "antiquewhite": [250, 235, 215],
        "aqua": [0, 255, 255],
        "aquamarine": [127, 255, 212],
        "azure": [240, 255, 255],
        "beige": [245, 245, 220],
        "bisque": [255, 228, 196],
        "black": [0, 0, 0],
        "blanchedalmond": [255, 235, 205],
        "blue": [0, 0, 255],
        "blueviolet": [138, 43, 226],
        "brown": [165, 42, 42],
        "burlywood": [222, 184, 135],
        "cadetblue": [95, 158, 160],
        "chartreuse": [127, 255, 0],
        "chocolate": [210, 105, 30],
        "coral": [255, 127, 80],
        "cornflowerblue": [100, 149, 237],
        "cornsilk": [255, 248, 220],
        "crimson": [220, 20, 60],
        "cyan": [0, 255, 255],
        "darkblue": [0, 0, 139],
        "darkcyan": [0, 139, 139],
        "darkgoldenrod": [184, 134, 11],
        "darkgray": [169, 169, 169],
        "darkgreen": [0, 100, 0],
        "darkgrey": [169, 169, 169],
        "darkkhaki": [189, 183, 107],
        "darkmagenta": [139, 0, 139],
        "darkolivegreen": [85, 107, 47],
        "darkorange": [255, 140, 0],
        "darkorchid": [153, 50, 204],
        "darkred": [139, 0, 0],
        "darksalmon": [233, 150, 122],
        "darkseagreen": [143, 188, 143],
        "darkslateblue": [72, 61, 139],
        "darkslategray": [47, 79, 79],
        "darkslategrey": [47, 79, 79],
        "darkturquoise": [0, 206, 209],
        "darkviolet": [148, 0, 211],
        "deeppink": [255, 20, 147],
        "deepskyblue": [0, 191, 255],
        "dimgray": [105, 105, 105],
        "dimgrey": [105, 105, 105],
        "dodgerblue": [30, 144, 255],
        "firebrick": [178, 34, 34],
        "floralwhite": [255, 250, 240],
        "forestgreen": [34, 139, 34],
        "fuchsia": [255, 0, 255],
        "gainsboro": [220, 220, 220],
        "ghostwhite": [248, 248, 255],
        "gold": [255, 215, 0],
        "goldenrod": [218, 165, 32],
        "gray": [128, 128, 128],
        "green": [0, 128, 0],
        "greenyellow": [173, 255, 47],
        "grey": [128, 128, 128],
        "honeydew": [240, 255, 240],
        "hotpink": [255, 105, 180],
        "indianred": [205, 92, 92],
        "indigo": [75, 0, 130],
        "ivory": [255, 255, 240],
        "khaki": [240, 230, 140],
        "lavender": [230, 230, 250],
        "lavenderblush": [255, 240, 245],
        "lawngreen": [124, 252, 0],
        "lemonchiffon": [255, 250, 205],
        "lightblue": [173, 216, 230],
        "lightcoral": [240, 128, 128],
        "lightcyan": [224, 255, 255],
        "lightgoldenrodyellow": [250, 250, 210],
        "lightgray": [211, 211, 211],
        "lightgreen": [144, 238, 144],
        "lightgrey": [211, 211, 211],
        "lightpink": [255, 182, 193],
        "lightsalmon": [255, 160, 122],
        "lightseagreen": [32, 178, 170],
        "lightskyblue": [135, 206, 250],
        "lightslategray": [119, 136, 153],
        "lightslategrey": [119, 136, 153],
        "lightsteelblue": [176, 196, 222],
        "lightyellow": [255, 255, 224],
        "lime": [0, 255, 0],
        "limegreen": [50, 205, 50],
        "linen": [250, 240, 230],
        "magenta": [255, 0, 255],
        "maroon": [128, 0, 0],
        "mediumaquamarine": [102, 205, 170],
        "mediumblue": [0, 0, 205],
        "mediumorchid": [186, 85, 211],
        "mediumpurple": [147, 112, 219],
        "mediumseagreen": [60, 179, 113],
        "mediumslateblue": [123, 104, 238],
        "mediumspringgreen": [0, 250, 154],
        "mediumturquoise": [72, 209, 204],
        "mediumvioletred": [199, 21, 133],
        "midnightblue": [25, 25, 112],
        "mintcream": [245, 255, 250],
        "mistyrose": [255, 228, 225],
        "moccasin": [255, 228, 181],
        "navajowhite": [255, 222, 173],
        "navy": [0, 0, 128],
        "oldlace": [253, 245, 230],
        "olive": [128, 128, 0],
        "olivedrab": [107, 142, 35],
        "orange": [255, 165, 0],
        "orangered": [255, 69, 0],
        "orchid": [218, 112, 214],
        "palegoldenrod": [238, 232, 170],
        "palegreen": [152, 251, 152],
        "paleturquoise": [175, 238, 238],
        "palevioletred": [219, 112, 147],
        "papayawhip": [255, 239, 213],
        "peachpuff": [255, 218, 185],
        "peru": [205, 133, 63],
        "pink": [255, 192, 203],
        "plum": [221, 160, 221],
        "powderblue": [176, 224, 230],
        "purple": [128, 0, 128],
        "rebeccapurple": [102, 51, 153],
        "red": [255, 0, 0],
        "rosybrown": [188, 143, 143],
        "royalblue": [65, 105, 225],
        "saddlebrown": [139, 69, 19],
        "salmon": [250, 128, 114],
        "sandybrown": [244, 164, 96],
        "seagreen": [46, 139, 87],
        "seashell": [255, 245, 238],
        "sienna": [160, 82, 45],
        "silver": [192, 192, 192],
        "skyblue": [135, 206, 235],
        "slateblue": [106, 90, 205],
        "slategray": [112, 128, 144],
        "slategrey": [112, 128, 144],
        "snow": [255, 250, 250],
        "springgreen": [0, 255, 127],
        "steelblue": [70, 130, 180],
        "tan": [210, 180, 140],
        "teal": [0, 128, 128],
        "thistle": [216, 191, 216],
        "tomato": [255, 99, 71],
        "turquoise": [64, 224, 208],
        "violet": [238, 130, 238],
        "wheat": [245, 222, 179],
        "white": [255, 255, 255],
        "whitesmoke": [245, 245, 245],
        "yellow": [255, 255, 0],
        "yellowgreen": [154, 205, 50]
      };
    }
  });

  // node_modules/color-convert/conversions.js
  var require_conversions = __commonJS({
    "node_modules/color-convert/conversions.js"(exports, module) {
      var cssKeywords = require_color_name();
      var reverseKeywords = {};
      for (const key of Object.keys(cssKeywords)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
      var convert = {
        rgb: {channels: 3, labels: "rgb"},
        hsl: {channels: 3, labels: "hsl"},
        hsv: {channels: 3, labels: "hsv"},
        hwb: {channels: 3, labels: "hwb"},
        cmyk: {channels: 4, labels: "cmyk"},
        xyz: {channels: 3, labels: "xyz"},
        lab: {channels: 3, labels: "lab"},
        lch: {channels: 3, labels: "lch"},
        hex: {channels: 1, labels: ["hex"]},
        keyword: {channels: 1, labels: ["keyword"]},
        ansi16: {channels: 1, labels: ["ansi16"]},
        ansi256: {channels: 1, labels: ["ansi256"]},
        hcg: {channels: 3, labels: ["h", "c", "g"]},
        apple: {channels: 3, labels: ["r16", "g16", "b16"]},
        gray: {channels: 1, labels: ["gray"]}
      };
      module.exports = convert;
      for (const model of Object.keys(convert)) {
        if (!("channels" in convert[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        const {channels, labels} = convert[model];
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], "channels", {value: channels});
        Object.defineProperty(convert[model], "labels", {value: labels});
      }
      convert.rgb.hsl = function(rgb) {
        const r2 = rgb[0] / 255;
        const g2 = rgb[1] / 255;
        const b2 = rgb[2] / 255;
        const min = Math.min(r2, g2, b2);
        const max = Math.max(r2, g2, b2);
        const delta = max - min;
        let h2;
        let s2;
        if (max === min) {
          h2 = 0;
        } else if (r2 === max) {
          h2 = (g2 - b2) / delta;
        } else if (g2 === max) {
          h2 = 2 + (b2 - r2) / delta;
        } else if (b2 === max) {
          h2 = 4 + (r2 - g2) / delta;
        }
        h2 = Math.min(h2 * 60, 360);
        if (h2 < 0) {
          h2 += 360;
        }
        const l2 = (min + max) / 2;
        if (max === min) {
          s2 = 0;
        } else if (l2 <= 0.5) {
          s2 = delta / (max + min);
        } else {
          s2 = delta / (2 - max - min);
        }
        return [h2, s2 * 100, l2 * 100];
      };
      convert.rgb.hsv = function(rgb) {
        let rdif;
        let gdif;
        let bdif;
        let h2;
        let s2;
        const r2 = rgb[0] / 255;
        const g2 = rgb[1] / 255;
        const b2 = rgb[2] / 255;
        const v2 = Math.max(r2, g2, b2);
        const diff3 = v2 - Math.min(r2, g2, b2);
        const diffc = function(c2) {
          return (v2 - c2) / 6 / diff3 + 1 / 2;
        };
        if (diff3 === 0) {
          h2 = 0;
          s2 = 0;
        } else {
          s2 = diff3 / v2;
          rdif = diffc(r2);
          gdif = diffc(g2);
          bdif = diffc(b2);
          if (r2 === v2) {
            h2 = bdif - gdif;
          } else if (g2 === v2) {
            h2 = 1 / 3 + rdif - bdif;
          } else if (b2 === v2) {
            h2 = 2 / 3 + gdif - rdif;
          }
          if (h2 < 0) {
            h2 += 1;
          } else if (h2 > 1) {
            h2 -= 1;
          }
        }
        return [
          h2 * 360,
          s2 * 100,
          v2 * 100
        ];
      };
      convert.rgb.hwb = function(rgb) {
        const r2 = rgb[0];
        const g2 = rgb[1];
        let b2 = rgb[2];
        const h2 = convert.rgb.hsl(rgb)[0];
        const w2 = 1 / 255 * Math.min(r2, Math.min(g2, b2));
        b2 = 1 - 1 / 255 * Math.max(r2, Math.max(g2, b2));
        return [h2, w2 * 100, b2 * 100];
      };
      convert.rgb.cmyk = function(rgb) {
        const r2 = rgb[0] / 255;
        const g2 = rgb[1] / 255;
        const b2 = rgb[2] / 255;
        const k2 = Math.min(1 - r2, 1 - g2, 1 - b2);
        const c2 = (1 - r2 - k2) / (1 - k2) || 0;
        const m2 = (1 - g2 - k2) / (1 - k2) || 0;
        const y2 = (1 - b2 - k2) / (1 - k2) || 0;
        return [c2 * 100, m2 * 100, y2 * 100, k2 * 100];
      };
      function comparativeDistance(x2, y2) {
        return (x2[0] - y2[0]) ** 2 + (x2[1] - y2[1]) ** 2 + (x2[2] - y2[2]) ** 2;
      }
      convert.rgb.keyword = function(rgb) {
        const reversed = reverseKeywords[rgb];
        if (reversed) {
          return reversed;
        }
        let currentClosestDistance = Infinity;
        let currentClosestKeyword;
        for (const keyword of Object.keys(cssKeywords)) {
          const value = cssKeywords[keyword];
          const distance = comparativeDistance(rgb, value);
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
        return currentClosestKeyword;
      };
      convert.keyword.rgb = function(keyword) {
        return cssKeywords[keyword];
      };
      convert.rgb.xyz = function(rgb) {
        let r2 = rgb[0] / 255;
        let g2 = rgb[1] / 255;
        let b2 = rgb[2] / 255;
        r2 = r2 > 0.04045 ? ((r2 + 0.055) / 1.055) ** 2.4 : r2 / 12.92;
        g2 = g2 > 0.04045 ? ((g2 + 0.055) / 1.055) ** 2.4 : g2 / 12.92;
        b2 = b2 > 0.04045 ? ((b2 + 0.055) / 1.055) ** 2.4 : b2 / 12.92;
        const x2 = r2 * 0.4124 + g2 * 0.3576 + b2 * 0.1805;
        const y2 = r2 * 0.2126 + g2 * 0.7152 + b2 * 0.0722;
        const z2 = r2 * 0.0193 + g2 * 0.1192 + b2 * 0.9505;
        return [x2 * 100, y2 * 100, z2 * 100];
      };
      convert.rgb.lab = function(rgb) {
        const xyz = convert.rgb.xyz(rgb);
        let x2 = xyz[0];
        let y2 = xyz[1];
        let z2 = xyz[2];
        x2 /= 95.047;
        y2 /= 100;
        z2 /= 108.883;
        x2 = x2 > 8856e-6 ? x2 ** (1 / 3) : 7.787 * x2 + 16 / 116;
        y2 = y2 > 8856e-6 ? y2 ** (1 / 3) : 7.787 * y2 + 16 / 116;
        z2 = z2 > 8856e-6 ? z2 ** (1 / 3) : 7.787 * z2 + 16 / 116;
        const l2 = 116 * y2 - 16;
        const a2 = 500 * (x2 - y2);
        const b2 = 200 * (y2 - z2);
        return [l2, a2, b2];
      };
      convert.hsl.rgb = function(hsl) {
        const h2 = hsl[0] / 360;
        const s2 = hsl[1] / 100;
        const l2 = hsl[2] / 100;
        let t2;
        let t3;
        let val;
        if (s2 === 0) {
          val = l2 * 255;
          return [val, val, val];
        }
        if (l2 < 0.5) {
          t2 = l2 * (1 + s2);
        } else {
          t2 = l2 + s2 - l2 * s2;
        }
        const t1 = 2 * l2 - t2;
        const rgb = [0, 0, 0];
        for (let i2 = 0; i2 < 3; i2++) {
          t3 = h2 + 1 / 3 * -(i2 - 1);
          if (t3 < 0) {
            t3++;
          }
          if (t3 > 1) {
            t3--;
          }
          if (6 * t3 < 1) {
            val = t1 + (t2 - t1) * 6 * t3;
          } else if (2 * t3 < 1) {
            val = t2;
          } else if (3 * t3 < 2) {
            val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
          } else {
            val = t1;
          }
          rgb[i2] = val * 255;
        }
        return rgb;
      };
      convert.hsl.hsv = function(hsl) {
        const h2 = hsl[0];
        let s2 = hsl[1] / 100;
        let l2 = hsl[2] / 100;
        let smin = s2;
        const lmin = Math.max(l2, 0.01);
        l2 *= 2;
        s2 *= l2 <= 1 ? l2 : 2 - l2;
        smin *= lmin <= 1 ? lmin : 2 - lmin;
        const v2 = (l2 + s2) / 2;
        const sv = l2 === 0 ? 2 * smin / (lmin + smin) : 2 * s2 / (l2 + s2);
        return [h2, sv * 100, v2 * 100];
      };
      convert.hsv.rgb = function(hsv) {
        const h2 = hsv[0] / 60;
        const s2 = hsv[1] / 100;
        let v2 = hsv[2] / 100;
        const hi = Math.floor(h2) % 6;
        const f2 = h2 - Math.floor(h2);
        const p2 = 255 * v2 * (1 - s2);
        const q2 = 255 * v2 * (1 - s2 * f2);
        const t2 = 255 * v2 * (1 - s2 * (1 - f2));
        v2 *= 255;
        switch (hi) {
          case 0:
            return [v2, t2, p2];
          case 1:
            return [q2, v2, p2];
          case 2:
            return [p2, v2, t2];
          case 3:
            return [p2, q2, v2];
          case 4:
            return [t2, p2, v2];
          case 5:
            return [v2, p2, q2];
        }
      };
      convert.hsv.hsl = function(hsv) {
        const h2 = hsv[0];
        const s2 = hsv[1] / 100;
        const v2 = hsv[2] / 100;
        const vmin = Math.max(v2, 0.01);
        let sl;
        let l2;
        l2 = (2 - s2) * v2;
        const lmin = (2 - s2) * vmin;
        sl = s2 * vmin;
        sl /= lmin <= 1 ? lmin : 2 - lmin;
        sl = sl || 0;
        l2 /= 2;
        return [h2, sl * 100, l2 * 100];
      };
      convert.hwb.rgb = function(hwb) {
        const h2 = hwb[0] / 360;
        let wh = hwb[1] / 100;
        let bl = hwb[2] / 100;
        const ratio = wh + bl;
        let f2;
        if (ratio > 1) {
          wh /= ratio;
          bl /= ratio;
        }
        const i2 = Math.floor(6 * h2);
        const v2 = 1 - bl;
        f2 = 6 * h2 - i2;
        if ((i2 & 1) !== 0) {
          f2 = 1 - f2;
        }
        const n2 = wh + f2 * (v2 - wh);
        let r2;
        let g2;
        let b2;
        switch (i2) {
          default:
          case 6:
          case 0:
            r2 = v2;
            g2 = n2;
            b2 = wh;
            break;
          case 1:
            r2 = n2;
            g2 = v2;
            b2 = wh;
            break;
          case 2:
            r2 = wh;
            g2 = v2;
            b2 = n2;
            break;
          case 3:
            r2 = wh;
            g2 = n2;
            b2 = v2;
            break;
          case 4:
            r2 = n2;
            g2 = wh;
            b2 = v2;
            break;
          case 5:
            r2 = v2;
            g2 = wh;
            b2 = n2;
            break;
        }
        return [r2 * 255, g2 * 255, b2 * 255];
      };
      convert.cmyk.rgb = function(cmyk) {
        const c2 = cmyk[0] / 100;
        const m2 = cmyk[1] / 100;
        const y2 = cmyk[2] / 100;
        const k2 = cmyk[3] / 100;
        const r2 = 1 - Math.min(1, c2 * (1 - k2) + k2);
        const g2 = 1 - Math.min(1, m2 * (1 - k2) + k2);
        const b2 = 1 - Math.min(1, y2 * (1 - k2) + k2);
        return [r2 * 255, g2 * 255, b2 * 255];
      };
      convert.xyz.rgb = function(xyz) {
        const x2 = xyz[0] / 100;
        const y2 = xyz[1] / 100;
        const z2 = xyz[2] / 100;
        let r2;
        let g2;
        let b2;
        r2 = x2 * 3.2406 + y2 * -1.5372 + z2 * -0.4986;
        g2 = x2 * -0.9689 + y2 * 1.8758 + z2 * 0.0415;
        b2 = x2 * 0.0557 + y2 * -0.204 + z2 * 1.057;
        r2 = r2 > 31308e-7 ? 1.055 * r2 ** (1 / 2.4) - 0.055 : r2 * 12.92;
        g2 = g2 > 31308e-7 ? 1.055 * g2 ** (1 / 2.4) - 0.055 : g2 * 12.92;
        b2 = b2 > 31308e-7 ? 1.055 * b2 ** (1 / 2.4) - 0.055 : b2 * 12.92;
        r2 = Math.min(Math.max(0, r2), 1);
        g2 = Math.min(Math.max(0, g2), 1);
        b2 = Math.min(Math.max(0, b2), 1);
        return [r2 * 255, g2 * 255, b2 * 255];
      };
      convert.xyz.lab = function(xyz) {
        let x2 = xyz[0];
        let y2 = xyz[1];
        let z2 = xyz[2];
        x2 /= 95.047;
        y2 /= 100;
        z2 /= 108.883;
        x2 = x2 > 8856e-6 ? x2 ** (1 / 3) : 7.787 * x2 + 16 / 116;
        y2 = y2 > 8856e-6 ? y2 ** (1 / 3) : 7.787 * y2 + 16 / 116;
        z2 = z2 > 8856e-6 ? z2 ** (1 / 3) : 7.787 * z2 + 16 / 116;
        const l2 = 116 * y2 - 16;
        const a2 = 500 * (x2 - y2);
        const b2 = 200 * (y2 - z2);
        return [l2, a2, b2];
      };
      convert.lab.xyz = function(lab) {
        const l2 = lab[0];
        const a2 = lab[1];
        const b2 = lab[2];
        let x2;
        let y2;
        let z2;
        y2 = (l2 + 16) / 116;
        x2 = a2 / 500 + y2;
        z2 = y2 - b2 / 200;
        const y22 = y2 ** 3;
        const x22 = x2 ** 3;
        const z22 = z2 ** 3;
        y2 = y22 > 8856e-6 ? y22 : (y2 - 16 / 116) / 7.787;
        x2 = x22 > 8856e-6 ? x22 : (x2 - 16 / 116) / 7.787;
        z2 = z22 > 8856e-6 ? z22 : (z2 - 16 / 116) / 7.787;
        x2 *= 95.047;
        y2 *= 100;
        z2 *= 108.883;
        return [x2, y2, z2];
      };
      convert.lab.lch = function(lab) {
        const l2 = lab[0];
        const a2 = lab[1];
        const b2 = lab[2];
        let h2;
        const hr = Math.atan2(b2, a2);
        h2 = hr * 360 / 2 / Math.PI;
        if (h2 < 0) {
          h2 += 360;
        }
        const c2 = Math.sqrt(a2 * a2 + b2 * b2);
        return [l2, c2, h2];
      };
      convert.lch.lab = function(lch) {
        const l2 = lch[0];
        const c2 = lch[1];
        const h2 = lch[2];
        const hr = h2 / 360 * 2 * Math.PI;
        const a2 = c2 * Math.cos(hr);
        const b2 = c2 * Math.sin(hr);
        return [l2, a2, b2];
      };
      convert.rgb.ansi16 = function(args, saturation = null) {
        const [r2, g2, b2] = args;
        let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
        value = Math.round(value / 50);
        if (value === 0) {
          return 30;
        }
        let ansi = 30 + (Math.round(b2 / 255) << 2 | Math.round(g2 / 255) << 1 | Math.round(r2 / 255));
        if (value === 2) {
          ansi += 60;
        }
        return ansi;
      };
      convert.hsv.ansi16 = function(args) {
        return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
      };
      convert.rgb.ansi256 = function(args) {
        const r2 = args[0];
        const g2 = args[1];
        const b2 = args[2];
        if (r2 === g2 && g2 === b2) {
          if (r2 < 8) {
            return 16;
          }
          if (r2 > 248) {
            return 231;
          }
          return Math.round((r2 - 8) / 247 * 24) + 232;
        }
        const ansi = 16 + 36 * Math.round(r2 / 255 * 5) + 6 * Math.round(g2 / 255 * 5) + Math.round(b2 / 255 * 5);
        return ansi;
      };
      convert.ansi16.rgb = function(args) {
        let color = args % 10;
        if (color === 0 || color === 7) {
          if (args > 50) {
            color += 3.5;
          }
          color = color / 10.5 * 255;
          return [color, color, color];
        }
        const mult = (~~(args > 50) + 1) * 0.5;
        const r2 = (color & 1) * mult * 255;
        const g2 = (color >> 1 & 1) * mult * 255;
        const b2 = (color >> 2 & 1) * mult * 255;
        return [r2, g2, b2];
      };
      convert.ansi256.rgb = function(args) {
        if (args >= 232) {
          const c2 = (args - 232) * 10 + 8;
          return [c2, c2, c2];
        }
        args -= 16;
        let rem;
        const r2 = Math.floor(args / 36) / 5 * 255;
        const g2 = Math.floor((rem = args % 36) / 6) / 5 * 255;
        const b2 = rem % 6 / 5 * 255;
        return [r2, g2, b2];
      };
      convert.rgb.hex = function(args) {
        const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
        const string = integer.toString(16).toUpperCase();
        return "000000".substring(string.length) + string;
      };
      convert.hex.rgb = function(args) {
        const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!match) {
          return [0, 0, 0];
        }
        let colorString = match[0];
        if (match[0].length === 3) {
          colorString = colorString.split("").map((char) => {
            return char + char;
          }).join("");
        }
        const integer = parseInt(colorString, 16);
        const r2 = integer >> 16 & 255;
        const g2 = integer >> 8 & 255;
        const b2 = integer & 255;
        return [r2, g2, b2];
      };
      convert.rgb.hcg = function(rgb) {
        const r2 = rgb[0] / 255;
        const g2 = rgb[1] / 255;
        const b2 = rgb[2] / 255;
        const max = Math.max(Math.max(r2, g2), b2);
        const min = Math.min(Math.min(r2, g2), b2);
        const chroma = max - min;
        let grayscale;
        let hue;
        if (chroma < 1) {
          grayscale = min / (1 - chroma);
        } else {
          grayscale = 0;
        }
        if (chroma <= 0) {
          hue = 0;
        } else if (max === r2) {
          hue = (g2 - b2) / chroma % 6;
        } else if (max === g2) {
          hue = 2 + (b2 - r2) / chroma;
        } else {
          hue = 4 + (r2 - g2) / chroma;
        }
        hue /= 6;
        hue %= 1;
        return [hue * 360, chroma * 100, grayscale * 100];
      };
      convert.hsl.hcg = function(hsl) {
        const s2 = hsl[1] / 100;
        const l2 = hsl[2] / 100;
        const c2 = l2 < 0.5 ? 2 * s2 * l2 : 2 * s2 * (1 - l2);
        let f2 = 0;
        if (c2 < 1) {
          f2 = (l2 - 0.5 * c2) / (1 - c2);
        }
        return [hsl[0], c2 * 100, f2 * 100];
      };
      convert.hsv.hcg = function(hsv) {
        const s2 = hsv[1] / 100;
        const v2 = hsv[2] / 100;
        const c2 = s2 * v2;
        let f2 = 0;
        if (c2 < 1) {
          f2 = (v2 - c2) / (1 - c2);
        }
        return [hsv[0], c2 * 100, f2 * 100];
      };
      convert.hcg.rgb = function(hcg) {
        const h2 = hcg[0] / 360;
        const c2 = hcg[1] / 100;
        const g2 = hcg[2] / 100;
        if (c2 === 0) {
          return [g2 * 255, g2 * 255, g2 * 255];
        }
        const pure = [0, 0, 0];
        const hi = h2 % 1 * 6;
        const v2 = hi % 1;
        const w2 = 1 - v2;
        let mg = 0;
        switch (Math.floor(hi)) {
          case 0:
            pure[0] = 1;
            pure[1] = v2;
            pure[2] = 0;
            break;
          case 1:
            pure[0] = w2;
            pure[1] = 1;
            pure[2] = 0;
            break;
          case 2:
            pure[0] = 0;
            pure[1] = 1;
            pure[2] = v2;
            break;
          case 3:
            pure[0] = 0;
            pure[1] = w2;
            pure[2] = 1;
            break;
          case 4:
            pure[0] = v2;
            pure[1] = 0;
            pure[2] = 1;
            break;
          default:
            pure[0] = 1;
            pure[1] = 0;
            pure[2] = w2;
        }
        mg = (1 - c2) * g2;
        return [
          (c2 * pure[0] + mg) * 255,
          (c2 * pure[1] + mg) * 255,
          (c2 * pure[2] + mg) * 255
        ];
      };
      convert.hcg.hsv = function(hcg) {
        const c2 = hcg[1] / 100;
        const g2 = hcg[2] / 100;
        const v2 = c2 + g2 * (1 - c2);
        let f2 = 0;
        if (v2 > 0) {
          f2 = c2 / v2;
        }
        return [hcg[0], f2 * 100, v2 * 100];
      };
      convert.hcg.hsl = function(hcg) {
        const c2 = hcg[1] / 100;
        const g2 = hcg[2] / 100;
        const l2 = g2 * (1 - c2) + 0.5 * c2;
        let s2 = 0;
        if (l2 > 0 && l2 < 0.5) {
          s2 = c2 / (2 * l2);
        } else if (l2 >= 0.5 && l2 < 1) {
          s2 = c2 / (2 * (1 - l2));
        }
        return [hcg[0], s2 * 100, l2 * 100];
      };
      convert.hcg.hwb = function(hcg) {
        const c2 = hcg[1] / 100;
        const g2 = hcg[2] / 100;
        const v2 = c2 + g2 * (1 - c2);
        return [hcg[0], (v2 - c2) * 100, (1 - v2) * 100];
      };
      convert.hwb.hcg = function(hwb) {
        const w2 = hwb[1] / 100;
        const b2 = hwb[2] / 100;
        const v2 = 1 - b2;
        const c2 = v2 - w2;
        let g2 = 0;
        if (c2 < 1) {
          g2 = (v2 - c2) / (1 - c2);
        }
        return [hwb[0], c2 * 100, g2 * 100];
      };
      convert.apple.rgb = function(apple) {
        return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
      };
      convert.rgb.apple = function(rgb) {
        return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
      };
      convert.gray.rgb = function(args) {
        return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
      };
      convert.gray.hsl = function(args) {
        return [0, 0, args[0]];
      };
      convert.gray.hsv = convert.gray.hsl;
      convert.gray.hwb = function(gray) {
        return [0, 100, gray[0]];
      };
      convert.gray.cmyk = function(gray) {
        return [0, 0, 0, gray[0]];
      };
      convert.gray.lab = function(gray) {
        return [gray[0], 0, 0];
      };
      convert.gray.hex = function(gray) {
        const val = Math.round(gray[0] / 100 * 255) & 255;
        const integer = (val << 16) + (val << 8) + val;
        const string = integer.toString(16).toUpperCase();
        return "000000".substring(string.length) + string;
      };
      convert.rgb.gray = function(rgb) {
        const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
        return [val / 255 * 100];
      };
    }
  });

  // node_modules/color-convert/route.js
  var require_route = __commonJS({
    "node_modules/color-convert/route.js"(exports, module) {
      var conversions = require_conversions();
      function buildGraph() {
        const graph = {};
        const models = Object.keys(conversions);
        for (let len = models.length, i2 = 0; i2 < len; i2++) {
          graph[models[i2]] = {
            distance: -1,
            parent: null
          };
        }
        return graph;
      }
      function deriveBFS(fromModel) {
        const graph = buildGraph();
        const queue = [fromModel];
        graph[fromModel].distance = 0;
        while (queue.length) {
          const current = queue.pop();
          const adjacents = Object.keys(conversions[current]);
          for (let len = adjacents.length, i2 = 0; i2 < len; i2++) {
            const adjacent = adjacents[i2];
            const node = graph[adjacent];
            if (node.distance === -1) {
              node.distance = graph[current].distance + 1;
              node.parent = current;
              queue.unshift(adjacent);
            }
          }
        }
        return graph;
      }
      function link(from, to) {
        return function(args) {
          return to(from(args));
        };
      }
      function wrapConversion(toModel, graph) {
        const path = [graph[toModel].parent, toModel];
        let fn = conversions[graph[toModel].parent][toModel];
        let cur = graph[toModel].parent;
        while (graph[cur].parent) {
          path.unshift(graph[cur].parent);
          fn = link(conversions[graph[cur].parent][cur], fn);
          cur = graph[cur].parent;
        }
        fn.conversion = path;
        return fn;
      }
      module.exports = function(fromModel) {
        const graph = deriveBFS(fromModel);
        const conversion = {};
        const models = Object.keys(graph);
        for (let len = models.length, i2 = 0; i2 < len; i2++) {
          const toModel = models[i2];
          const node = graph[toModel];
          if (node.parent === null) {
            continue;
          }
          conversion[toModel] = wrapConversion(toModel, graph);
        }
        return conversion;
      };
    }
  });

  // node_modules/color-convert/index.js
  var require_color_convert = __commonJS({
    "node_modules/color-convert/index.js"(exports, module) {
      var conversions = require_conversions();
      var route = require_route();
      var convert = {};
      var models = Object.keys(conversions);
      function wrapRaw(fn) {
        const wrappedFn = function(...args) {
          const arg0 = args[0];
          if (arg0 === void 0 || arg0 === null) {
            return arg0;
          }
          if (arg0.length > 1) {
            args = arg0;
          }
          return fn(args);
        };
        if ("conversion" in fn) {
          wrappedFn.conversion = fn.conversion;
        }
        return wrappedFn;
      }
      function wrapRounded(fn) {
        const wrappedFn = function(...args) {
          const arg0 = args[0];
          if (arg0 === void 0 || arg0 === null) {
            return arg0;
          }
          if (arg0.length > 1) {
            args = arg0;
          }
          const result = fn(args);
          if (typeof result === "object") {
            for (let len = result.length, i2 = 0; i2 < len; i2++) {
              result[i2] = Math.round(result[i2]);
            }
          }
          return result;
        };
        if ("conversion" in fn) {
          wrappedFn.conversion = fn.conversion;
        }
        return wrappedFn;
      }
      models.forEach((fromModel) => {
        convert[fromModel] = {};
        Object.defineProperty(convert[fromModel], "channels", {value: conversions[fromModel].channels});
        Object.defineProperty(convert[fromModel], "labels", {value: conversions[fromModel].labels});
        const routes = route(fromModel);
        const routeModels = Object.keys(routes);
        routeModels.forEach((toModel) => {
          const fn = routes[toModel];
          convert[fromModel][toModel] = wrapRounded(fn);
          convert[fromModel][toModel].raw = wrapRaw(fn);
        });
      });
      module.exports = convert;
    }
  });

  // node_modules/file-saver/dist/FileSaver.min.js
  var require_FileSaver_min = __commonJS({
    "node_modules/file-saver/dist/FileSaver.min.js"(exports, module) {
      (function(a2, b2) {
        if (typeof define == "function" && define.amd)
          define([], b2);
        else if (typeof exports != "undefined")
          b2();
        else {
          b2(), a2.FileSaver = {exports: {}}.exports;
        }
      })(exports, function() {
        "use strict";
        function b2(a3, b3) {
          return typeof b3 == "undefined" ? b3 = {autoBom: false} : typeof b3 != "object" && (console.warn("Deprecated: Expected third argument to be a object"), b3 = {autoBom: !b3}), b3.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a3.type) ? new Blob(["\uFEFF", a3], {type: a3.type}) : a3;
        }
        function c2(a3, b3, c3) {
          var d3 = new XMLHttpRequest();
          d3.open("GET", a3), d3.responseType = "blob", d3.onload = function() {
            g2(d3.response, b3, c3);
          }, d3.onerror = function() {
            console.error("could not download file");
          }, d3.send();
        }
        function d2(a3) {
          var b3 = new XMLHttpRequest();
          b3.open("HEAD", a3, false);
          try {
            b3.send();
          } catch (a4) {
          }
          return 200 <= b3.status && 299 >= b3.status;
        }
        function e2(a3) {
          try {
            a3.dispatchEvent(new MouseEvent("click"));
          } catch (c3) {
            var b3 = document.createEvent("MouseEvents");
            b3.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), a3.dispatchEvent(b3);
          }
        }
        var f2 = typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof global == "object" && global.global === global ? global : void 0, a2 = f2.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g2 = f2.saveAs || (typeof window != "object" || window !== f2 ? function() {
        } : "download" in HTMLAnchorElement.prototype && !a2 ? function(b3, g3, h2) {
          var i2 = f2.URL || f2.webkitURL, j2 = document.createElement("a");
          g3 = g3 || b3.name || "download", j2.download = g3, j2.rel = "noopener", typeof b3 == "string" ? (j2.href = b3, j2.origin === location.origin ? e2(j2) : d2(j2.href) ? c2(b3, g3, h2) : e2(j2, j2.target = "_blank")) : (j2.href = i2.createObjectURL(b3), setTimeout(function() {
            i2.revokeObjectURL(j2.href);
          }, 4e4), setTimeout(function() {
            e2(j2);
          }, 0));
        } : "msSaveOrOpenBlob" in navigator ? function(f3, g3, h2) {
          if (g3 = g3 || f3.name || "download", typeof f3 != "string")
            navigator.msSaveOrOpenBlob(b2(f3, h2), g3);
          else if (d2(f3))
            c2(f3, g3, h2);
          else {
            var i2 = document.createElement("a");
            i2.href = f3, i2.target = "_blank", setTimeout(function() {
              e2(i2);
            });
          }
        } : function(b3, d3, e3, g3) {
          if (g3 = g3 || open("", "_blank"), g3 && (g3.document.title = g3.document.body.innerText = "downloading..."), typeof b3 == "string")
            return c2(b3, d3, e3);
          var h2 = b3.type === "application/octet-stream", i2 = /constructor/i.test(f2.HTMLElement) || f2.safari, j2 = /CriOS\/[\d]+/.test(navigator.userAgent);
          if ((j2 || h2 && i2 || a2) && typeof FileReader != "undefined") {
            var k2 = new FileReader();
            k2.onloadend = function() {
              var a3 = k2.result;
              a3 = j2 ? a3 : a3.replace(/^data:[^;]*;/, "data:attachment/file;"), g3 ? g3.location.href = a3 : location = a3, g3 = null;
            }, k2.readAsDataURL(b3);
          } else {
            var l2 = f2.URL || f2.webkitURL, m2 = l2.createObjectURL(b3);
            g3 ? g3.location = m2 : location.href = m2, g3 = null, setTimeout(function() {
              l2.revokeObjectURL(m2);
            }, 4e4);
          }
        });
        f2.saveAs = g2.saveAs = g2, typeof module != "undefined" && (module.exports = g2);
      });
    }
  });

  // src/csv.ts
  function parseCsv(content) {
    const lines = content.split(/\r?\n/g);
    const result = {
      headers: lines[0].split(/,/g),
      rows: lines.slice(1).map((s2) => s2.split(/,/g))
    };
    for (const r2 of result.rows) {
      if (r2.length !== result.headers.length) {
        throw new Error(`Malformed line: ${JSON.stringify(r2)} length doesn't match header size (${result.headers.length})`);
      }
    }
    return result;
  }

  // src/color-data.ts
  function loadColorData() {
    const colorDataRaw = parseCsv(require_colors());
    const rows = assertCsv(colorDataRaw, ["R", "G", "B", "Artkal Midi Soft", "Artkal Mini Soft", "Artkal Mini", "Artkal Midi", "Name"]);
    const colorData2 = [];
    for (const r2 of rows) {
      for (let i2 = 3; i2 < r2.length - 1; i2++) {
        if (r2[i2].length) {
          colorData2.push({
            name: r2[r2.length - 1],
            code: r2[i2],
            r: +r2[0],
            R: +r2[0],
            g: +r2[1],
            G: +r2[1],
            b: +r2[2],
            B: +r2[2]
          });
        }
      }
    }
    return colorData2;
  }
  function assertCsv(c2, headers) {
    if (JSON.stringify(headers) !== JSON.stringify(c2.headers))
      throw new Error("Headers don't match");
    return c2.rows;
  }

  // src/utils.tsx
  var preact = (init_preact_module(), preact_module_exports);
  var diff = require_lib();
  var symbolAlphabet = "ABCDEFGHJKLMNPQRSTVXZ\u03B1\u03B2\u0394\u03B8\u03BB\u03C0\u03A6\u03A8\u03A9abcdefghijklmnopqrstuvwxyz0123456789";
  var pitchInfo = {
    "artkal-mini": 2.82,
    "perler-mini": 2.69,
    perler: 5.1,
    lego: 8
  };
  function getPitch(size) {
    return pitchInfo[size];
  }
  function colorEntryToHtml(c2) {
    return "rgb(" + c2.r + "," + c2.g + "," + c2.b + ")";
  }
  function colorEntryToHex(c2) {
    return "#" + hx(c2.r) + hx(c2.g) + hx(c2.b);
  }
  function hx(n2) {
    if (n2 === void 0)
      return "";
    if (n2 === 0)
      return "00";
    if (n2 < 16)
      return "0" + n2.toString(16);
    return n2.toString(16);
  }
  function isBright(i2) {
    return i2.r + i2.g * 1.4 + i2.b > 460;
  }
  function timer() {
    let last = Date.now();
    return {mark};
    function mark(event) {
      const n2 = Date.now();
      last = n2;
    }
  }
  function radioGroup(name, changed, defaultValue, values) {
    const v2 = values[name];
    return /* @__PURE__ */ preact.h(preact.Fragment, null, v2.map(([value, caption]) => {
      return /* @__PURE__ */ preact.h("label", {
        key: value
      }, /* @__PURE__ */ preact.h("input", {
        type: "radio",
        onChange: changed,
        name,
        value,
        defaultChecked: value === defaultValue
      }), caption);
    }));
  }
  function carve(width, height, xSize, ySize) {
    const res = [];
    const xa = carveAxis(width, xSize);
    const ya = carveAxis(height, ySize);
    let cy = 0;
    for (const y2 of ya) {
      let cx = 0;
      for (const x2 of xa) {
        res.push({
          x: cx,
          y: cy,
          width: x2,
          height: y2
        });
        cx += x2;
      }
      cy += y2;
    }
    return res;
  }
  function carveAxis(width, size) {
    if (width <= size)
      return [width];
    if (width <= size * 2) {
      return [Math.ceil(width / 2), Math.floor(width / 2)];
    }
    const remainder = width % size;
    let res = [remainder];
    let remaining = width - res[0];
    while (remaining > size) {
      res.push(size);
      remaining -= size;
    }
    res.push(remaining);
    return res;
  }

  // src/display-settings.tsx
  var preact2 = (init_preact_module(), preact_module_exports);
  var DisplaySettings = {
    planStyle: [
      ["symbolspans", "Symbols + Spans"],
      ["spans", "Spans"],
      ["symbols", "Symbols"],
      ["none", "None"]
    ],
    grid: [
      ["56", "56"],
      ["50", "50"],
      ["29", "29"],
      ["28", "28"],
      ["10", "10"],
      ["none", "None"]
    ],
    background: [
      ["#555", "Grey"],
      ["#000", "Black"],
      ["#FFF", "White"],
      ["transparent", "Transparent"],
      ["url(#wood)", "Wood"]
    ],
    refobj: [
      ["none", "None"],
      ["quarter", "Quarter"],
      ["dollar", "Dollar"],
      ["credit", "Bank Card"]
    ]
  };
  function createDisplaySettingsComponent(onChange) {
    return {
      component,
      value
    };
    function changed() {
      onChange();
    }
    function value() {
      const p2 = new FormData(document.getElementById("displaysettingsform"));
      const entries = [...p2.entries()];
      return Object.fromEntries(entries);
    }
    function component() {
      return /* @__PURE__ */ preact2.h("form", {
        id: "displaysettingsform"
      }, /* @__PURE__ */ preact2.h("div", {
        className: "options-group"
      }, /* @__PURE__ */ preact2.h("span", {
        className: "header"
      }, "Legend"), radioGroup("planStyle", changed, "symbolspans", DisplaySettings)), /* @__PURE__ */ preact2.h("div", {
        className: "options-group"
      }, /* @__PURE__ */ preact2.h("span", {
        className: "header"
      }, "Grid"), radioGroup("grid", changed, "50", DisplaySettings)), /* @__PURE__ */ preact2.h("div", {
        className: "options-group"
      }, /* @__PURE__ */ preact2.h("span", {
        className: "header"
      }, "Background"), radioGroup("background", changed, "#555", DisplaySettings)), /* @__PURE__ */ preact2.h("div", {
        className: "options-group"
      }, /* @__PURE__ */ preact2.h("span", {
        className: "header"
      }, "Comparison"), radioGroup("refobj", changed, "none", DisplaySettings)));
    }
  }

  // src/download-bar.tsx
  var preact3 = (init_preact_module(), preact_module_exports);
  var PrinterSettings = {
    paperSize: [
      ["letter", "Letter"],
      ["A4", "A4"],
      ["fit", "Fit"]
    ],
    style: [
      ["stepped", "Step-by-Step"],
      ["single", "Single Plan"]
    ],
    color: [
      ["bw-min", "Monochrome (ink-saver)"],
      ["bw-max", "Monochrome"],
      ["color", "Color"]
    ],
    correction: [
      ["1", "None"],
      ["1.04166667", "104.2%"]
    ],
    skew: [
      ["none", "None"],
      ["low", "Low"],
      ["medium", "Medium"],
      ["high", "High"]
    ],
    carveSize: [
      ["none", "None"],
      ["50", "50x50"]
    ]
  };
  function createDownloadBar(onRequest) {
    return {
      component
    };
    function download(s2) {
      return function(e2) {
        e2.preventDefault();
        onRequest(s2, value());
      };
    }
    function changed() {
    }
    function value() {
      const p2 = new FormData(document.getElementById("printsettingsform"));
      const entries = [...p2.entries()];
      return Object.fromEntries(entries);
    }
    function component() {
      return /* @__PURE__ */ preact3.h("form", {
        id: "printsettingsform"
      }, /* @__PURE__ */ preact3.h("div", {
        className: "options-group"
      }, /* @__PURE__ */ preact3.h("span", {
        className: "header"
      }, "Plan Images"), /* @__PURE__ */ preact3.h("label", null, /* @__PURE__ */ preact3.h("a", {
        href: "#",
        onClick: download("svg")
      }, "SVG")), /* @__PURE__ */ preact3.h("label", null, /* @__PURE__ */ preact3.h("a", {
        href: "#",
        onClick: download("txt")
      }, "Text")), /* @__PURE__ */ preact3.h("label", null, /* @__PURE__ */ preact3.h("a", {
        href: "#",
        onClick: download("png")
      }, "PNG"))), /* @__PURE__ */ preact3.h("div", {
        className: "options-group"
      }, /* @__PURE__ */ preact3.h("span", {
        className: "header"
      }, "Page Size"), radioGroup("paperSize", changed, "letter", PrinterSettings)), /* @__PURE__ */ preact3.h("div", {
        className: "options-group"
      }, /* @__PURE__ */ preact3.h("span", {
        className: "header"
      }, "Color"), radioGroup("color", changed, "bw-max", PrinterSettings)), /* @__PURE__ */ preact3.h("div", {
        className: "options-group"
      }, /* @__PURE__ */ preact3.h("span", {
        className: "header"
      }, "Style"), radioGroup("style", changed, "stepped", PrinterSettings)), /* @__PURE__ */ preact3.h("div", {
        className: "options-group"
      }, /* @__PURE__ */ preact3.h("span", {
        className: "header"
      }, "Scale Correction"), radioGroup("correction", changed, "1.04166667", PrinterSettings)), /* @__PURE__ */ preact3.h("div", {
        className: "options-group"
      }, /* @__PURE__ */ preact3.h("span", {
        className: "header"
      }, "Perspective Correction"), radioGroup("skew", changed, "none", PrinterSettings)), /* @__PURE__ */ preact3.h("div", {
        className: "options-group"
      }, /* @__PURE__ */ preact3.h("span", {
        className: "header"
      }, "Segmenting"), radioGroup("carveSize", changed, "none", PrinterSettings)), /* @__PURE__ */ preact3.h("div", {
        className: "options-group"
      }, /* @__PURE__ */ preact3.h("span", {
        className: "header"
      }, "Printable Underlay"), /* @__PURE__ */ preact3.h("label", null, /* @__PURE__ */ preact3.h("a", {
        href: "#",
        onClick: download("pdf")
      }, "Get PDF")), /* @__PURE__ */ preact3.h("label", null, /* @__PURE__ */ preact3.h("a", {
        href: "#",
        onClick: download("calibration")
      }, "Get Calibration Sheet"))));
    }
  }

  // src/gallery.tsx
  var preact4 = (init_preact_module(), preact_module_exports);
  function Gallery({load, gallery, requestDelete}) {
    const cells = gallery.map((name, index) => {
      return /* @__PURE__ */ preact4.h(GalleryCell, {
        key: name + "." + index,
        src: `${name}`,
        onClick: () => load(name),
        onDeleteClick: () => requestDelete(index)
      });
    });
    cells.reverse();
    return /* @__PURE__ */ preact4.h("div", {
      className: "gallery-list"
    }, cells);
  }
  function GalleryCell(props) {
    return /* @__PURE__ */ preact4.h("div", {
      className: "gallery-entry",
      onClick: props.onClick
    }, /* @__PURE__ */ preact4.h("img", {
      src: props.src
    }), /* @__PURE__ */ preact4.h("div", {
      className: "gallery-delete",
      onClick: (e2) => {
        e2.preventDefault();
        e2.stopPropagation();
        props.onDeleteClick();
      }
    }, "\u274C"));
  }

  // src/image-utils.tsx
  var colorConvert = require_color_convert();
  function imageDataToRgbaArray(imageData) {
    const raw = [];
    for (let y2 = 0; y2 < imageData.height; y2++) {
      const row = [];
      for (let x2 = 0; x2 < imageData.width; x2++) {
        const b2 = 4 * (y2 * imageData.width + x2);
        if (imageData.data[b2 + 3] === 255) {
          row.push((imageData.data[b2 + 2] << 16) + (imageData.data[b2 + 1] << 8) + imageData.data[b2]);
        } else {
          row.push(-1);
        }
      }
      raw.push(row);
    }
    return {
      pixels: raw,
      width: imageData.width,
      height: imageData.height
    };
  }
  function applyImageAdjustments(rgbaArray, brightness, contrast, saturation) {
    if (brightness === 0 && contrast === 0 && saturation === 0)
      return;
    const data = rgbaArray.pixels;
    for (let y2 = 0; y2 < rgbaArray.height; y2++) {
      for (let x2 = 0; x2 < rgbaArray.width; x2++) {
        const p2 = data[y2][x2];
        if (p2 === -1)
          continue;
        const hsv = colorConvert.rgb.hsv(p2 & 255, p2 >> 8 & 255, p2 >> 16 & 255);
        if (contrast > 0) {
          hsv[2] = clamp(0, (hsv[2] - 50) * (1 + contrast / 7) + 50, 100);
        } else if (contrast < 0) {
          hsv[2] = clamp(0, (hsv[2] - 50) * (1 + contrast / 10) + 50, 100);
        }
        hsv[1] = clamp(0, hsv[1] + saturation * 5, 100);
        hsv[2] = clamp(0, hsv[2] + brightness * 5, 100);
        const rgb = colorConvert.hsv.rgb(hsv);
        data[y2][x2] = rgb[0] | 0 | rgb[1] << 8 | rgb[2] << 16;
      }
    }
  }
  function clamp(min, v2, max) {
    return Math.max(min, Math.min(v2, max));
  }
  function applyTransparencyAndCrop(rgbaArray, transparentValue) {
    let minY = Infinity, maxY = -Infinity;
    let minX = Infinity, maxX = -Infinity;
    for (let y2 = 0; y2 < rgbaArray.height; y2++) {
      for (let x2 = 0; x2 < rgbaArray.width; x2++) {
        if (rgbaArray.pixels[y2][x2] !== transparentValue) {
          minX = Math.min(minX, x2);
          maxX = Math.max(maxX, x2);
          minY = Math.min(minY, y2);
          maxY = Math.max(maxY, y2);
        }
      }
    }
    const pixels = [];
    for (let y2 = minY; y2 <= maxY; y2++) {
      const row = [];
      for (let x2 = minX; x2 <= maxX; x2++) {
        const v2 = rgbaArray.pixels[y2][x2];
        if (v2 === transparentValue) {
          row.push(-1);
        } else {
          row.push(v2);
        }
      }
      pixels.push(row);
    }
    return {
      pixels,
      width: maxX - minX + 1,
      height: maxY - minY + 1
    };
  }
  function getImageData(img) {
    const canvas = document.createElement("canvas");
    canvas.width = img.width;
    canvas.height = img.height;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0, img.width, img.height);
    const imageData = ctx.getImageData(0, 0, img.width, img.height);
    return imageData;
  }
  function inferTransparencyValue(rgbaArray) {
    let hasEdgeMagenta = false;
    for (let y2 = 0; y2 < rgbaArray.height; y2++) {
      const isYedge = y2 === 0 || y2 === rgbaArray.height - 1;
      for (let x2 = 0; x2 < rgbaArray.width; x2++) {
        if (rgbaArray.pixels[y2][x2] === -1) {
          return -1;
        }
        const rv = rgbaArray.pixels[y2][x2];
        if (isYedge || x2 === 0 || x2 === rgbaArray.width - 1) {
          hasEdgeMagenta = hasEdgeMagenta || rv === 16711935;
        }
      }
    }
    if (hasEdgeMagenta)
      return 16711935;
    return getCornerTransparency(rgbaArray);
  }
  function getCornerTransparency(rgbaArray) {
    const arr = [
      rgbaArray.pixels[0][0],
      rgbaArray.pixels[rgbaArray.height - 1][0],
      rgbaArray.pixels[rgbaArray.height - 1][rgbaArray.width - 1],
      rgbaArray.pixels[0][rgbaArray.width - 1]
    ];
    arr.sort();
    return arr[2];
  }

  // src/palettizer.ts
  var diff2 = require_lib();
  function palettize(rgbaArray, palette) {
    const pixels = [];
    for (let y2 = 0; y2 < rgbaArray.height; y2++) {
      const row = [];
      for (let x2 = 0; x2 < rgbaArray.width; x2++) {
        if (rgbaArray.pixels[y2][x2] === -1) {
          row.push(void 0);
        } else {
          const paletteEntry = palette.filter((p2) => p2.color === rgbaArray.pixels[y2][x2])[0];
          row.push(paletteEntry.target);
        }
      }
      pixels.push(row);
    }
    return {
      pixels,
      width: rgbaArray.width,
      height: rgbaArray.height
    };
  }
  function makePalette(rgbaArray, allowedColors, settings) {
    const tempAssignments = [];
    const inputColors = [];
    for (let y2 = 0; y2 < rgbaArray.height; y2++) {
      for (let x2 = 0; x2 < rgbaArray.width; x2++) {
        const color = rgbaArray.pixels[y2][x2];
        if (color === -1)
          continue;
        const extant = inputColors.filter((r2) => r2.color === color)[0];
        if (extant) {
          extant.count++;
        } else {
          inputColors.push({
            color,
            count: 1,
            r: color & 255,
            g: color >> 8 & 255,
            b: color >> 16 & 255
          });
        }
      }
    }
    inputColors.sort((a2, b2) => b2.count - a2.count);
    const diff3 = colorDiff[settings.colormatch];
    for (const r2 of inputColors) {
      if (allowedColors === void 0) {
        let R = r2.color & 255, G = r2.color >> 8 & 255, B = r2.color >> 16 & 255;
        tempAssignments.push({
          color: r2.color,
          target: {
            R,
            G,
            B,
            r: R,
            g: G,
            b: B,
            name: colorEntryToHex({r: R, g: G, b: B}),
            code: ""
          },
          count: r2.count
        });
      } else {
        let bestTarget = void 0;
        let bestScore = Infinity;
        for (const c2 of allowedColors) {
          if (settings.nodupes) {
            if (tempAssignments.some((t2) => t2.target === c2))
              continue;
          }
          const score = diff3(r2, c2);
          if (score < bestScore) {
            bestTarget = c2;
            bestScore = score;
          }
        }
        if (bestTarget === void 0)
          throw new Error("impossible");
        tempAssignments.push({
          color: r2.color,
          target: bestTarget,
          count: r2.count
        });
      }
    }
    return tempAssignments;
  }
  var colorDiff = {
    rgb: (lhs, rhs) => {
      return Math.pow(lhs.r - rhs.r, 2) * 3 + Math.pow(lhs.g - rhs.g, 2) * 4 + Math.pow(lhs.b - rhs.b, 2) * 2;
    },
    "CIEDE2000": (lhs, rhs) => {
      return diff2.diff(diff2.rgb_to_lab({R: lhs.r, G: lhs.g, B: lhs.b}), diff2.rgb_to_lab({R: rhs.r, G: rhs.g, B: rhs.b}));
    }
  };

  // src/pdf-generator.ts
  function correctionToNumber(n2) {
    return +n2;
  }
  async function makePdf(image, planSettings, printOptions) {
    loadPdfAnd(() => makePdfWorker(image, planSettings, printOptions));
  }
  async function loadPdfAnd(func) {
    const tagName = "pdf-script-tag";
    const scriptEl = document.getElementById(tagName);
    if (scriptEl === null) {
      const tag = document.createElement("script");
      tag.id = tagName;
      tag.onload = () => {
        func();
      };
      tag.src = "https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.3.1/jspdf.umd.min.js";
      document.head.appendChild(tag);
    } else {
      func();
    }
  }
  function makeTestSheet() {
    loadPdfAnd(() => {
      const marginX = 30;
      const marginY = 30;
      const doc = new jspdf.jsPDF({
        unit: "mm",
        format: [200, 200]
      });
      const text = `firaga.io Printer Test Sheet

Print this page at 100% scale and check it with a ruler`;
      doc.text(text, marginX, marginY, {maxWidth: 200 - marginX * 2});
      doc.setFontSize(12);
      let y2 = 20 + marginY;
      calib(0, "Metric");
      calib(100, "If this line is exactly 100mm, you have correct calibration");
      calib(100 * 100 / 96, "If this line is exactly 100mm, set your printer scale to 104.2%");
      calib(96, "If this line is exactly 100mm, set your printer scale to 96%");
      calib(0, "Imperial");
      calib(25.4 * 5, "If this line is exactly 5 inches, you have correct calibration");
      calib(25.4 * 5 * 100 / 96, "If this line is exactly 5 inches, set your printer scale to 104.2%");
      calib(25.4 * 5 * 96 / 100, "If this line is exactly 5 inches, set your printer scale to 96%");
      function calib(length, text2) {
        doc.setFontSize(length === 0 ? 14 : 12);
        doc.text(text2, marginX, y2, {baseline: "top", maxWidth: 200 - marginX * 2});
        if (length !== 0) {
          doc.line(marginX, y2 + 6, marginX + length, y2 + 6);
        }
        y2 += 14;
      }
      doc.save("plan.pdf");
    });
  }
  function makePdfWorker(image, planSettings, printOptions) {
    let pitch = getPitch(planSettings.size);
    pitch = pitch * correctionToNumber(printOptions.correction);
    const carveSize = printOptions.carveSize === "none" ? [image.width, image.height] : [50, 50];
    const pageMargins = {
      left: 25.4 / 2,
      right: 25.4 / 2,
      bottom: 25.4 / 2,
      top: 25.4 / 2
    };
    const minimumGridMargin = 2;
    const skewThickness = {
      "none": 0,
      "low": 3,
      "medium": 6,
      "high": 14
    }[printOptions.skew];
    const observerHeight = 17 * 25.4;
    const observerDistance = 8 * 25.4;
    const minTheta = Math.atan2(observerHeight, observerDistance);
    const maxTheta = Math.atan2(observerHeight, observerDistance + carveSize[1] * pitch);
    const minPerspectiveOffset = Math.tan(maxTheta) * skewThickness;
    const maxPerspectiveOffset = Math.tan(minTheta) * skewThickness;
    const netPerspectiveOffset = maxPerspectiveOffset - minPerspectiveOffset;
    const textHeight = 4;
    const gridSize = {
      width: pitch * Math.min(image.width, carveSize[0]),
      height: pitch * Math.min(image.height, carveSize[1]) + netPerspectiveOffset
    };
    const cellSize = {
      width: gridSize.width,
      height: gridSize.height + textHeight
    };
    let orientation = "";
    let paperWidth, paperHeight;
    let rows = 1, cols = 1;
    if (printOptions.paperSize === "fit") {
      paperWidth = cellSize.width;
      paperHeight = cellSize.height;
      orientation = cellSize.width > cellSize.height ? "landscape" : "portrait";
    } else if (printOptions.paperSize === "letter") {
      paperWidth = 8.5 * 25.4;
      paperHeight = 11 * 25.4;
    } else if (printOptions.paperSize === "A4") {
      paperWidth = 210;
      paperHeight = 297;
    } else {
      throw new Error(printOptions.paperSize);
    }
    const printableAreaSize = {
      width: paperWidth - pageMargins.left - pageMargins.right,
      height: paperHeight - pageMargins.bottom - pageMargins.top
    };
    if (printOptions.paperSize !== "fit") {
      const layout = getLayout(printableAreaSize.width, printableAreaSize.height, gridSize.width, gridSize.height, image.partList.length, minimumGridMargin);
      rows = layout.rows;
      cols = layout.cols;
      orientation = layout.orientation;
    }
    const finalWidth = orientation === "landscape" ? printableAreaSize.height : printableAreaSize.width;
    const finalHeight = orientation === "landscape" ? printableAreaSize.width : printableAreaSize.height;
    const doc = new jspdf.jsPDF({
      unit: "mm",
      format: [paperWidth, paperHeight],
      orientation
    });
    let rowCursor = 0, colCursor = -1;
    const slices = carve(image.width, image.height, carveSize[0], carveSize[1]);
    if (slices.length > 1) {
      doc.setFont("Helvetica");
      doc.setFontSize(12);
      doc.setFillColor(0, 0, 0);
      const sliceScale = 1 / 2;
      for (let i2 = 0; i2 < slices.length; i2++) {
        let x2 = pageMargins.left + slices[i2].x * sliceScale;
        let y2 = pageMargins.top + slices[i2].y * sliceScale;
        doc.rect(x2, y2, slices[i2].width * sliceScale, slices[i2].height * sliceScale);
        doc.text(symbolAlphabet[i2], x2 + slices[i2].width / 2 * sliceScale, y2 + slices[i2].height / 2 * sliceScale, {baseline: "middle", align: "center"});
      }
      doc.addPage();
    }
    doc.setFont("Helvetica");
    doc.setFontSize(7);
    doc.setFillColor(0, 0, 0);
    const ctx = doc.context2d;
    const horizontalGridMargin = (finalWidth - cols * cellSize.width) / (cols + 1);
    const verticalGridMargin = (finalHeight - rows * cellSize.height) / (rows + 1);
    ctx.translate(horizontalGridMargin, verticalGridMargin);
    if (printOptions.style === "stepped") {
      for (let i2 = 0; i2 < image.partList.length; i2++) {
        for (let si = 0; si < slices.length; si++) {
          const slice = slices[si];
          let realCount = 0;
          for (let y2 = slice.y; y2 < slice.y + slice.height; y2++) {
            for (let x2 = slice.x; x2 < slice.x + slice.width; x2++) {
              if (image.pixels[y2][x2] === image.partList[i2]) {
                realCount++;
              }
            }
          }
          if (realCount === 0)
            continue;
          nextCellLocation();
          const yAt = (rawY) => {
            const adjY = rawY - slice.y;
            const rowTheta = Math.atan2(observerHeight, observerDistance + adjY * pitch);
            const ySkew = maxPerspectiveOffset - Math.tan(rowTheta) * skewThickness;
            return (adjY + 0.5) * pitch + ySkew;
          };
          ctx.save();
          ctx.font = "4pt Helvetica";
          ctx.translate(colCursor * (cellSize.width + horizontalGridMargin) + pageMargins.top, rowCursor * (cellSize.height + verticalGridMargin) + pageMargins.left);
          const text = slices.length === 1 ? `${image.partList[i2].target.code} (${image.partList[i2].target.name})` : `Cell ${symbolAlphabet[si]}: ${image.partList[i2].target.code} (${image.partList[i2].target.name})`;
          ctx.textBaseline = "top";
          ctx.fillText(text, 0, 0, cellSize.width);
          ctx.translate(0, textHeight);
          ctx.lineWidth = 0.01;
          ctx.strokeStyle = "grey";
          ctx.strokeRect(0, 0, gridSize.width, gridSize.height);
          if (printOptions.color === "color") {
            ctx.fillStyle = colorEntryToHex(image.partList[i2].target);
          } else {
            ctx.fillStyle = "black";
          }
          ctx.beginPath();
          for (let y2 = slice.y; y2 < slice.y + slice.height; y2++) {
            const cy = yAt(y2);
            for (let x2 = slice.x; x2 < slice.x + slice.width; x2++) {
              if (image.pixels[y2][x2] === image.partList[i2]) {
                ctx.arc((x2 - slice.x + 0.5) * pitch, cy, pitch / 2.5, 0, Math.PI * 2, false);
              }
            }
          }
          if (printOptions.color === "bw-min") {
            ctx.stroke();
          } else {
            ctx.fill();
          }
          ctx.closePath();
          ctx.beginPath();
          const prevFill = [];
          for (let y2 = slice.y; y2 < slice.y + slice.height; y2++) {
            const row = [];
            for (let x2 = slice.x; x2 < slice.x + slice.width; x2++) {
              let prev = false;
              for (let j2 = 0; j2 < i2; j2++) {
                if (image.pixels[y2][x2] === image.partList[j2]) {
                  prev = true;
                  break;
                }
              }
              row.push(prev);
            }
            prevFill.push(row);
          }
          for (let y2 = slice.y; y2 < slice.y + slice.height; y2++) {
            const py = y2 - slice.y;
            const yTop = yAt(y2 - 0.5);
            const yBottom = yAt(y2 + 0.5);
            for (let x2 = slice.x; x2 < slice.x + slice.width; x2++) {
              const px = x2 - slice.x;
              if (prevFill[py][px]) {
                if (py !== 0 && !prevFill[y2 - 1][px]) {
                  ctx.moveTo((px + 0) * pitch, yTop);
                  ctx.lineTo((px + 1) * pitch, yTop);
                }
                if (py !== prevFill.length - 1 && !prevFill[y2 + 1][px]) {
                  ctx.moveTo((px + 0) * pitch, yBottom);
                  ctx.lineTo((px + 1) * pitch, yBottom);
                }
                if (!prevFill[y2][px - 1]) {
                  ctx.moveTo(px * pitch, yTop);
                  ctx.lineTo(px * pitch, yBottom);
                }
                if (!prevFill[y2][px + 1]) {
                  ctx.moveTo((px + 1) * pitch, yTop);
                  ctx.lineTo((px + 1) * pitch, yBottom);
                }
              }
            }
          }
          ctx.stroke();
          ctx.closePath();
          ctx.restore();
        }
      }
    } else if (printOptions.style === "single") {
      for (let si = 0; si < slices.length; si++) {
        nextCellLocation();
        ctx.translate(pageMargins.top, pageMargins.left);
        const slice = slices[si];
        for (let y2 = slice.y; y2 < slice.y + slice.height; y2++) {
          for (let x2 = slice.x; x2 < slice.x + slice.width; x2++) {
            const px = image.pixels[y2][x2];
            if (px !== void 0) {
              if (printOptions.color === "color") {
                ctx.fillStyle = colorEntryToHex(px.target);
              } else {
                ctx.fillStyle = "black";
              }
              for (let i2 = 0; i2 < image.partList.length; i2++) {
                if (image.partList[i2] === px) {
                  ctx.fillText(symbolAlphabet[i2], (x2 - slice.x + 0.15) * pitch, (y2 - slice.y + 1) * pitch);
                }
              }
            }
          }
        }
      }
    }
    doc.output("dataurlnewwindow", {filename: "plan.pdf"});
    function nextCellLocation() {
      colCursor++;
      if (colCursor === cols) {
        colCursor = 0;
        rowCursor++;
        if (rowCursor === rows) {
          doc.addPage();
          rowCursor = 0;
        }
      }
    }
  }
  function getLayout(printableWidth, printableHeight, cellWidth, cellHeight, cellCount, minumumMargin) {
    const landscape = {
      orientation: "landscape",
      ...tryLayout(printableHeight, printableWidth)
    };
    const portrait = {
      orientation: "portrait",
      ...tryLayout(printableWidth, printableHeight)
    };
    if (portrait.rows * portrait.cols >= cellCount) {
      if (landscape.rows * landscape.cols >= cellCount) {
        return landscape.rows * landscape.cols < portrait.rows * portrait.cols ? landscape : portrait;
      }
      return portrait;
    }
    return landscape.rows * landscape.cols > portrait.rows * portrait.cols ? landscape : portrait;
    function tryLayout(pageWidth, pageHeight) {
      let rows = Math.floor((pageHeight + minumumMargin) / (cellHeight + minumumMargin));
      let cols = Math.floor((pageWidth + minumumMargin) / (cellWidth + minumumMargin));
      while (true) {
        if (rows > cols) {
          if (tryDecr(() => rows--))
            continue;
          if (tryDecr(() => cols--))
            continue;
        } else {
          if (tryDecr(() => cols--))
            continue;
          if (tryDecr(() => rows--))
            continue;
        }
        break;
      }
      return {rows, cols};
      function tryDecr(f2) {
        let or = rows, oc = cols;
        f2();
        if (rows * cols < cellCount) {
          rows = or;
          cols = oc;
          return false;
        }
        return true;
      }
    }
  }

  // src/plan-settings.tsx
  var preact5 = (init_preact_module(), preact_module_exports);
  var PlanSettings = {
    transparency: [
      ["auto", "Auto"],
      ["alpha", "Alpha Channel"],
      ["magenta", "Magenta"],
      ["corners", "Corners"],
      ["none", "None"]
    ],
    palette: [
      ["artkal-mini-starter", "Artkal Mini Starter Set"],
      ["artkal-all-mini", "All Artkal Mini"],
      ["all", "All Colors"]
    ],
    size: [
      ["artkal-mini", "Artkal Mini"],
      ["perler-mini", "Perler Mini"],
      ["perler", "Standard"],
      ["lego", "LEGO \u2122"]
    ]
  };
  function createPlannerSettingsComponent(firedChanged) {
    return {
      component,
      value
    };
    function changed() {
      firedChanged();
    }
    function value() {
      const p2 = new FormData(document.getElementById("plan-settings-form"));
      const entries = [...p2.entries()];
      return Object.fromEntries(entries);
    }
    function component() {
      return /* @__PURE__ */ preact5.h("form", {
        id: "plan-settings-form"
      }, /* @__PURE__ */ preact5.h("div", {
        className: "options-group"
      }, /* @__PURE__ */ preact5.h("span", {
        className: "header"
      }, "Transparency"), radioGroup("transparency", changed, "auto", PlanSettings)), /* @__PURE__ */ preact5.h("div", {
        className: "options-group"
      }, /* @__PURE__ */ preact5.h("span", {
        className: "header"
      }, "Adjustments"), /* @__PURE__ */ preact5.h("label", null, /* @__PURE__ */ preact5.h("input", {
        type: "range",
        onInput: changed,
        onChange: changed,
        min: "-10",
        max: "10",
        step: "1",
        defaultValue: 0,
        name: "brightness"
      }), "Brightness"), /* @__PURE__ */ preact5.h("label", null, /* @__PURE__ */ preact5.h("input", {
        type: "range",
        onInput: changed,
        onChange: changed,
        min: "-10",
        max: "10",
        step: "1",
        defaultValue: 0,
        name: "contrast"
      }), "Contrast"), /* @__PURE__ */ preact5.h("label", null, /* @__PURE__ */ preact5.h("input", {
        type: "range",
        onInput: changed,
        onChange: changed,
        min: "-10",
        max: "10",
        step: "1",
        defaultValue: 0,
        name: "saturation"
      }), "Saturation")), /* @__PURE__ */ preact5.h("div", {
        className: "options-group"
      }, /* @__PURE__ */ preact5.h("span", {
        className: "header"
      }, "Color Matching"), /* @__PURE__ */ preact5.h("label", null, /* @__PURE__ */ preact5.h("input", {
        type: "radio",
        onChange: changed,
        name: "colormatch",
        value: "CIEDE2000",
        defaultChecked: true
      }), "CIEDE200"), /* @__PURE__ */ preact5.h("label", null, /* @__PURE__ */ preact5.h("input", {
        type: "radio",
        onChange: changed,
        name: "colormatch",
        value: "rgb"
      }), "RGB"), /* @__PURE__ */ preact5.h("label", null, /* @__PURE__ */ preact5.h("input", {
        type: "checkbox",
        onChange: changed,
        name: "nodupes"
      }), "No Duplicates")), /* @__PURE__ */ preact5.h("div", {
        className: "options-group"
      }, /* @__PURE__ */ preact5.h("span", {
        className: "header"
      }, "Palette"), radioGroup("palette", changed, "artkal-mini-starter", PlanSettings)), /* @__PURE__ */ preact5.h("div", {
        className: "options-group"
      }, /* @__PURE__ */ preact5.h("span", {
        className: "header"
      }, "Pixel Size"), radioGroup("size", changed, "artkal-mini", PlanSettings)));
    }
  }

  // src/firaga.tsx
  var saver = require_FileSaver_min();
  var preact6 = (init_preact_module(), preact_module_exports);
  var refObjs = {
    quarter: {
      url: "https://upload.wikimedia.org/wikipedia/commons/4/44/2014_ATB_Quarter_Obv.png",
      width: 24.26,
      height: 24.26
    },
    dollar: {
      url: "https://upload.wikimedia.org/wikipedia/commons/2/23/US_one_dollar_bill%2C_obverse%2C_series_2009.jpg",
      width: 156.1,
      height: 66.3
    },
    credit: {
      url: "https://upload.wikimedia.org/wikipedia/commons/2/23/CIDSampleAmex.png",
      width: 85.6,
      height: 53.98
    }
  };
  var colorData = loadColorData();
  var artkalStarterCodes = "CT1,C01,C88,C33,C34,C02,C51,C47,C23,C31,C32,C78,C22,C44,C07,C09,C05,C57,C50,C25,C26,C52,C27,C64,C10,C42,C48,C03,C04,C17,C12,C13,C14,C86,C15,C70,C39,C60,C79,C54,C81,C82,C68,C19,C38,C20,C37,C21".split(",");
  function app() {
    let last = null;
    const planSettingsComp = createPlannerSettingsComponent(render);
    preact6.render(planSettingsComp.component(), document.getElementById("plan-settings"));
    const displaySettingsComp = createDisplaySettingsComponent(render);
    preact6.render(displaySettingsComp.component(), document.getElementById("display-settings"));
    const downloadBar = createDownloadBar(download);
    preact6.render(downloadBar.component(), document.getElementById("print-settings"));
    const gallery = [...predefinedGallery];
    for (let i2 = 0; i2 < 100; i2++) {
      const e2 = window.localStorage.getItem(keyFormat(i2));
      if (e2 !== null) {
        gallery.push(e2);
      }
    }
    renderGallery();
    setupDropbox();
    const myImg = document.getElementById("myImg");
    myImg.onload = function() {
      render();
    };
    const gi = +window.localStorage.getItem("gallery-index");
    if (gallery[gi]) {
      myImg.src = gallery[gi];
    } else {
      myImg.src = gallery[gallery.length - 1];
    }
    const planSvg = document.getElementById("plan");
    listenForImagePastes((src) => {
      acceptUserImage(src);
    });
    function setupDropbox() {
      const dropbox = document.getElementById("drop-target");
      dropbox.addEventListener("dragenter", (e2) => (e2.stopPropagation(), e2.preventDefault()), false);
      dropbox.addEventListener("dragover", (e2) => (e2.stopPropagation(), e2.preventDefault()), false);
      dropbox.addEventListener("drop", function(e2) {
        e2.stopPropagation();
        e2.preventDefault();
        const files = e2.dataTransfer?.files;
        if (!files)
          return;
        for (let i2 = 0; i2 < files.length; i2++) {
          const file = files[i2];
          if (!file.type.startsWith("image/"))
            continue;
          const reader = new FileReader();
          reader.onload = (img) => {
            acceptUserImage(img.target.result);
          };
          reader.readAsDataURL(file);
        }
      }, false);
    }
    function download(name, opts) {
      switch (name) {
        case "calibration":
          makeTestSheet();
          break;
        case "pdf":
          makePdf(last.partListImage, last.planSettings, opts);
          break;
        default:
          throw new Error(name);
      }
    }
    function render() {
      last = renderWorker();
    }
    function renderWorker() {
      const planSettings = planSettingsComp.value();
      const imageData = getImageData(myImg);
      const {palette, quantized, rgbaArray} = processImage(imageData, planSettings);
      const displaySettings = displaySettingsComp.value();
      const pli = createPartListImage(palette, quantized);
      renderPlan(planSvg, pli, planSettings, displaySettings);
      showPartList(pli.partList, {
        pitch: getPitch(planSettings.size),
        width: rgbaArray.width,
        height: rgbaArray.height
      });
      return {
        palette,
        quantized,
        partList: pli.partList,
        partListImage: pli,
        planSettings,
        displaySettings
      };
    }
    function acceptUserImage(src) {
      myImg.src = src;
      window.localStorage.setItem("gallery-index", gallery.length.toString());
      gallery.push(src);
      renderGallery();
      window.setTimeout(resaveGallery, 100);
    }
    function renderGallery() {
      preact6.render(/* @__PURE__ */ preact6.h(Gallery, {
        gallery,
        load: (name) => {
          const gi2 = gallery.indexOf(name);
          window.localStorage.setItem("gallery-index", gi2.toString());
          myImg.src = `${name}`;
        },
        requestDelete: (index) => {
          gallery.splice(index, 1);
          renderGallery();
          setTimeout(resaveGallery, 50);
        }
      }), document.getElementById("gallery-list"));
    }
    function resaveGallery() {
      let userIndex = 0;
      for (let i2 = 0; i2 < 101; i2++) {
        if (predefinedGallery.includes(gallery[i2]))
          continue;
        if (gallery[i2] === void 0) {
          window.localStorage.removeItem(keyFormat(userIndex));
        } else {
          saveTo(gallery[i2], userIndex);
        }
        userIndex++;
      }
      async function saveTo(blobUrl, index) {
        const blob = await (await fetch(blobUrl)).blob();
        const reader = new FileReader();
        reader.readAsDataURL(blob);
        reader.onloadend = function() {
          window.localStorage.setItem(keyFormat(index), reader.result);
        };
      }
    }
  }
  function processImage(imageData, planSettings) {
    const {mark} = timer();
    const uncroppedRgbaArray = imageDataToRgbaArray(imageData);
    mark("Image -> RGBA");
    let transparency;
    switch (planSettings.transparency) {
      case "auto":
        mark("Infer transparency");
        transparency = inferTransparencyValue(uncroppedRgbaArray);
        break;
      case "alpha":
        transparency = -1;
        break;
      case "none":
        transparency = NaN;
        break;
      case "magenta":
        transparency = 16711935;
        break;
      case "corners":
        transparency = getCornerTransparency(uncroppedRgbaArray);
        break;
    }
    const rgbaArray = applyTransparencyAndCrop(uncroppedRgbaArray, transparency);
    mark("Apply transparency & crop");
    applyImageAdjustments(rgbaArray, planSettings.brightness, planSettings.contrast, planSettings.saturation);
    mark("Adjust image");
    let allowedColors;
    switch (planSettings.palette) {
      case "artkal-all-mini":
        allowedColors = colorData.filter((c2) => c2.code.startsWith("C"));
        break;
      case "artkal-mini-starter":
        allowedColors = colorData.filter((c2) => artkalStarterCodes.includes(c2.code));
        break;
      case "all":
        allowedColors = void 0;
        break;
      default:
        allowedColors = colorData;
        break;
    }
    const palette = makePalette(rgbaArray, allowedColors, planSettings);
    mark("Create palette");
    const quantized = palettize(rgbaArray, palette);
    mark("Apply palette");
    return {
      palette,
      rgbaArray,
      quantized
    };
  }
  function createPartListImage(palette, quantized) {
    const partList = getPartList(palette);
    const res = new Array(quantized.height);
    const lookup = new Map();
    for (const e2 of palette) {
      lookup.set(e2.target, partList.filter((p2) => p2.target === e2.target)[0]);
    }
    for (let y2 = 0; y2 < quantized.height; y2++) {
      res[y2] = new Array(quantized.width);
      for (let x2 = 0; x2 < quantized.width; x2++) {
        if (quantized.pixels[y2][x2] === void 0) {
          res[y2][x2] = void 0;
        } else {
          res[y2][x2] = lookup.get(quantized.pixels[y2][x2]);
        }
      }
    }
    return {
      pixels: res,
      width: quantized.width,
      height: quantized.height,
      partList
    };
  }
  var keyFormat = (i2) => `saved-image-${i2}`;
  function listenForImagePastes(callback) {
    window.addEventListener("paste", function(evt) {
      const e2 = evt;
      for (const item of e2.clipboardData?.items ?? []) {
        if (item.type.indexOf("image") !== -1) {
          var blob = item.getAsFile();
          var source = URL.createObjectURL(blob);
          callback(source);
        }
      }
    });
  }
  function showPartList(partList, stats) {
    preact6.render(/* @__PURE__ */ preact6.h(preact6.Fragment, null, /* @__PURE__ */ preact6.h("table", {
      className: "part-list"
    }, /* @__PURE__ */ preact6.h("thead", null, /* @__PURE__ */ preact6.h("tr", null, /* @__PURE__ */ preact6.h("th", {
      colSpan: 5,
      className: "top-header"
    }, "Legend"))), /* @__PURE__ */ preact6.h("tbody", null, partList.map((ent) => {
      return /* @__PURE__ */ preact6.h("tr", {
        key: ent.symbol + ent.count + ent.target.name
      }, /* @__PURE__ */ preact6.h("td", {
        className: "legend-symbol"
      }, ent.symbol), /* @__PURE__ */ preact6.h("td", {
        className: "part-count"
      }, ent.count.toLocaleString()), /* @__PURE__ */ preact6.h("td", {
        className: "color-code"
      }, ent.target.code), /* @__PURE__ */ preact6.h("td", {
        style: {color: colorEntryToHex(ent.target)}
      }, "\u2B24"), /* @__PURE__ */ preact6.h("td", null, /* @__PURE__ */ preact6.h("span", {
        className: "colorName"
      }, ent.target.name)));
    }))), /* @__PURE__ */ preact6.h("table", {
      className: "plan-stats"
    }, /* @__PURE__ */ preact6.h("thead", null, /* @__PURE__ */ preact6.h("tr", null, /* @__PURE__ */ preact6.h("th", {
      colSpan: 4,
      className: "top-header"
    }, "Statistics"))), /* @__PURE__ */ preact6.h("tbody", null, /* @__PURE__ */ preact6.h("tr", null, /* @__PURE__ */ preact6.h("td", {
      className: "stat-label"
    }, "Width"), /* @__PURE__ */ preact6.h("td", {
      className: "stat-value"
    }, stats.width.toLocaleString(), "px"), /* @__PURE__ */ preact6.h("td", {
      className: "stat-value"
    }, fmt(stats.width * stats.pitch), "mm"), /* @__PURE__ */ preact6.h("td", {
      className: "stat-value"
    }, fmt(stats.width * stats.pitch / 25.4), '"')), /* @__PURE__ */ preact6.h("tr", null, /* @__PURE__ */ preact6.h("td", {
      className: "stat-label"
    }, "Height"), /* @__PURE__ */ preact6.h("td", {
      className: "stat-value"
    }, stats.height.toLocaleString(), "px"), /* @__PURE__ */ preact6.h("td", {
      className: "stat-value"
    }, fmt(stats.height * stats.pitch), "mm"), /* @__PURE__ */ preact6.h("td", {
      className: "stat-value"
    }, fmt(stats.height * stats.pitch / 25.4), '"')), /* @__PURE__ */ preact6.h("tr", null, /* @__PURE__ */ preact6.h("td", {
      className: "stat-label"
    }, "Pixels"), /* @__PURE__ */ preact6.h("td", {
      colSpan: 4,
      className: "stat-value"
    }, partList.reduce((a2, b2) => a2 + b2.count, 0).toLocaleString()))))), document.getElementById("legend"));
    function fmt(n2) {
      return n2.toFixed(2);
    }
  }
  function renderPlan(svg, image, planSettings, displaySettings) {
    const svgns = "http://www.w3.org/2000/svg";
    const colorLayer = document.getElementById("layer-colors");
    const gridLayer = document.getElementById("layer-grid");
    const textLayer = document.getElementById("layer-text");
    const refobjLayer = document.getElementById("layer-refobj");
    document.getElementById("plan-background")?.setAttribute("fill", displaySettings.background);
    svg.removeChild(colorLayer);
    svg.removeChild(gridLayer);
    svg.removeChild(textLayer);
    svg.removeChild(refobjLayer);
    clearChildren(colorLayer);
    clearChildren(gridLayer);
    clearChildren(textLayer);
    clearChildren(refobjLayer);
    const isBackgroundDark = displaySettings.background === "#000" || displaySettings.background === "#555";
    for (let i2 = 0; i2 < image.partList.length; i2++) {
      const parts = [];
      for (let y2 = 0; y2 < image.height; y2++) {
        for (let x2 = 0; x2 < image.width; x2++) {
          if (image.pixels[y2][x2] === image.partList[i2]) {
            parts.push(`M ${x2 * 32} ${y2 * 32} l 32 0 l 0 32 l -32 0 l 0 -32 z`);
          }
        }
      }
      const r2 = document.createElementNS(svgns, "path");
      r2.setAttribute("d", parts.join(" "));
      r2.setAttribute("fill", colorEntryToHtml(image.partList[i2].target));
      r2.setAttribute("stroke-width", "1px");
      r2.addEventListener("mouseenter", () => console.log(image.partList[i2].target.name));
      r2.addEventListener("mouseenter", () => {
        r2.setAttribute("stroke", "white");
      });
      r2.addEventListener("mouseleave", () => {
        r2.setAttribute("stroke", "");
      });
      colorLayer.appendChild(r2);
    }
    if (displaySettings.planStyle === "symbols") {
      for (let y2 = 0; y2 < image.height; y2++) {
        for (let x2 = 0; x2 < image.width; x2++) {
          const px = image.pixels[y2][x2];
          if (px === void 0)
            continue;
          const t2 = document.createElementNS(svgns, "text");
          t2.innerHTML = px.symbol;
          t2.setAttribute("x", (x2 + 0.5) * 32);
          t2.setAttribute("y", (y2 + 0.8) * 32);
          t2.setAttribute("text-anchor", "middle");
          if (isBright(px.target)) {
            t2.setAttribute("class", "bright");
          } else {
            t2.setAttribute("class", "dark");
          }
          textLayer.appendChild(t2);
        }
      }
    }
    if (displaySettings.planStyle === "spans" || displaySettings.planStyle === "symbolspans") {
      let addAt = function(px, runCount, endX, y2) {
        if (displaySettings.planStyle === "spans") {
          if (runCount < 2)
            return;
        } else {
          if (px === void 0)
            return;
        }
        const t2 = document.createElementNS(svgns, "text");
        if (displaySettings.planStyle === "spans") {
          t2.innerHTML = runCount.toString();
        } else {
          const sym = px?.symbol;
          if (runCount === 1) {
            t2.innerHTML = sym;
          } else if (runCount === 2) {
            t2.innerHTML = `${sym}`;
          } else {
            t2.innerHTML = `${sym}\xD7${runCount.toString()}`;
          }
        }
        t2.setAttribute("x", ((endX - runCount / 2) * 32).toString());
        t2.setAttribute("y", ((y2 + 0.8) * 32).toString());
        t2.setAttribute("text-anchor", "middle");
        if (px === void 0 ? !isBackgroundDark : isBright(px.target)) {
          t2.setAttribute("class", "bright");
        } else {
          t2.setAttribute("class", "dark");
        }
        textLayer.appendChild(t2);
      };
      for (let y2 = 0; y2 < image.height; y2++) {
        let nowColor = void 0;
        let runCount = 0;
        for (let x2 = 0; x2 <= image.width; x2++) {
          const px = image.pixels[y2][x2];
          if (nowColor === px) {
            runCount++;
          } else {
            if (runCount > 0) {
              addAt(nowColor, runCount, x2, y2);
            }
            nowColor = px;
            runCount = 1;
          }
          if (x2 === image.width)
            break;
        }
      }
    }
    if (displaySettings.grid !== "none") {
      const gridInterval = +displaySettings.grid;
      for (let y2 = 1; y2 < image.height; y2++) {
        const line = document.createElementNS(svgns, "line");
        line.classList.add("gridline");
        line.classList.add(y2 % gridInterval === 0 ? "gridmajor" : "gridminor");
        line.setAttribute("x1", 2);
        line.setAttribute("x2", image.width * 32 - 4);
        line.setAttribute("y1", y2 * 32);
        line.setAttribute("y2", y2 * 32);
        gridLayer.appendChild(line);
      }
      for (let x2 = 1; x2 < image.width; x2++) {
        const line = document.createElementNS(svgns, "line");
        line.classList.add(x2 % gridInterval === 0 ? "gridmajor" : "gridminor");
        line.setAttribute("x1", x2 * 32);
        line.setAttribute("x2", x2 * 32);
        line.setAttribute("y1", 2);
        line.setAttribute("y2", image.height * 32 - 4);
        gridLayer.appendChild(line);
      }
    }
    if (displaySettings.refobj !== "none") {
      const factor = 32 / getPitch(planSettings.size);
      const img = document.createElementNS(svgns, "image");
      const refObj = refObjs[displaySettings.refobj];
      img.setAttribute("href", refObj.url);
      img.setAttribute("width", refObj.width * factor);
      img.setAttribute("height", refObj.height * factor);
      img.setAttribute("opacity", 0.8);
      img.setAttribute("x", image.width * 32 - refObj.width * factor);
      img.setAttribute("y", image.height * 32 - refObj.height * factor);
      refobjLayer.appendChild(img);
    }
    svg.setAttribute("viewBox", `0 0 ${image.width * 32} ${image.height * 32}`);
    svg.appendChild(gridLayer);
    svg.appendChild(colorLayer);
    svg.appendChild(textLayer);
    svg.appendChild(refobjLayer);
    function clearChildren(el) {
      el.innerHTML = "";
    }
  }
  function getPartList(palette) {
    const res = [];
    for (const ent of palette) {
      const extant = res.filter((e2) => e2.target === ent.target)[0];
      if (extant) {
        extant.count += ent.count;
      } else {
        res.push({count: ent.count, target: ent.target, symbol: "#"});
      }
    }
    res.sort((a2, b2) => b2.count - a2.count);
    for (let i2 = 0; i2 < res.length; i2++) {
      res[i2].symbol = symbolAlphabet[i2];
    }
    return res;
  }
  window.addEventListener("DOMContentLoaded", function() {
    app();
  });
  var predefinedGallery = [
    "squirtle",
    "mario-3",
    "megaman_x",
    "earthbound",
    "kirby",
    "mushroom",
    "crono",
    "ghost-smw",
    "mew",
    "link-nes",
    "mario-cape",
    "ghost",
    "link",
    "eevee",
    "mario-1",
    "gannon",
    "ken",
    "shyguy",
    "brachiosaur",
    "sonic",
    "smw-plant"
  ].map((s2) => `./gallery/${s2}.png`).reverse();
})();
/**
 * @author Markus Ekholm
 * @copyright 2012-2016 (c) Markus Ekholm <markus at botten dot org >
 * @license Copyright (c) 2012-2016, Markus Ekholm
 * All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *    * Neither the name of the author nor the
 *      names of its contributors may be used to endorse or promote products
 *      derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL MARKUS EKHOLM BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
